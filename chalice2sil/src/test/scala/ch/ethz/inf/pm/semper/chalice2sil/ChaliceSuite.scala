package ch.ethz.inf.pm.semper.chalice2sil

import silAST.programs.{Program => SilProgram}
import ch.ethz.inf.pm.semper.chalice2sil.{Program => Chalice2Sil}
import scala.collection.JavaConversions._
import java.nio.file.{Files, Paths}
import org.scalatest._

/**
  * Author: Christian Klauser
  */

/**
  * A functional test suite backed by a directory with *.chalice files. It will turn all *.chalice files in that
  * directory into a test. You can optionally attach additional assertions to each of these files.
  * The \@RunWith annotation is only necessary when you want to run this suite in JUnit-based runners.
  * {{{
  *   package ch.ethz.inf.pm.semper.chalice2sil
  *   import org.scalatest.junit.JUnitRunner
  *
  *   @RunWith(classOf[JUnitRunner])
  *   class Translation extends ChaliceSuite {
  *
  *     'local.chalice {
  *       assert(program.methods != null) //`program` contains the translated AST
  *       assert(messages.isEmpty)        //`messages` contains the generated messages
  *     }
  *
  *   }
  * }}}

  }*/
abstract class ChaliceSuite extends FunSuite { //
  /**
    * The directory this test suite is associated with. Defaults to the fully qualified name of your test suite with dots replaced by slashes.
    * You are welcome to override this in subclasses.
    */
  val directoryPath = Paths.get(getClass.getName.replace(".","/") + "_")

  protected lazy val absoluteDirectoryPath = { //
    val rootUrl = getClass.getClassLoader.getResource("index.toc")
    Predef.assert(rootUrl != null,"Cannot find unit test resource root.")
    val root = Paths.get(rootUrl.toURI).getParent
    root.resolve(directoryPath)
  }

  /**
    * The SIL AST for the translated Chalice program.
    */
  var program : SilProgram = null

  /**
    * The sequence of messages generated by Chalice2Sil.
    */
  var messages : Seq[Message] = null
  
  private val explicitFiles = collection.mutable.Set[Symbol]()
  
  protected class ChaliceSymbolWrapper(symbol : Symbol) {
    def chalice(t : => Unit) { //
      explicitFiles += symbol
      val fileName = symbol.name + ".chalice"
      test(fileName){
        val opts = new ProgramOptions
        opts.chaliceFiles += absoluteDirectoryPath.resolve(fileName).toString
        opts.printSil = true

        Chalice2Sil.invokeChalice(opts) match {
          case None =>
            fail("Chalice failed to parse/typecheck file %s. See Stdout for more details.".format(fileName))
          case Some(p) =>
            val (silProgram, silMessages) = Chalice2Sil.translateToSil(opts, p)
            silMessages.view.filter(_.severity.indicatesFailure).foreach(m => fail("Detected message that indicates failure: %s".format(m)))

            Console.out.println(silProgram.toString)

            //now apply the additional assertions
            Predef.assert(program == null,"program is still assigned.")
            Predef.assert(messages == null, "messages is still assigned.")
            program = silProgram
            messages = silMessages            
            try{              
              t
            } finally {
              program = null
              messages = null
            }
        }
      }
    }
  }
  
  protected implicit def symbolToChaliceSymbolWrapper(symbol : Symbol) : ChaliceSymbolWrapper = new ChaliceSymbolWrapper(symbol)

  /**
    * Invoked during initialization to generate tests for all *.chalice files in the directory
    * that were not mentioned in the test suite. If you don't want this behaviour, just override this
    * method with an empty body.
    */
  protected def translateImplicitFiles() { //
    require(!implicitFilesRegistered,"implicit files already registered.")

    val dirStream = Files.newDirectoryStream(absoluteDirectoryPath,"*.chalice")
    val implicitFiles = try { //
      dirStream
        .map(p => Symbol(p.getFileName.toString.dropRight(".chalice".length)))
        .filterNot(explicitFiles.contains(_))
        .toList
    } finally { //
      dirStream.close()    
    }

    val doNothing = {}
    implicitFiles.foreach(_.chalice(doNothing))

    implicitFilesRegistered = true
  }
  
  private var implicitFilesRegistered = false
  protected final def ensureImplicitFilesRegistered(){
    if(implicitFilesRegistered) return
    
    translateImplicitFiles()
  }

  override def testNames = {
    ensureImplicitFilesRegistered()
    super.testNames
  }

  protected override def runTest(testName : String, reporter : Reporter, stopper : Stopper, configMap : Map[String, Any], tracker : Tracker) {//
    ensureImplicitFilesRegistered()
    super.runTest(testName, reporter, stopper, configMap, tracker)
  }

  protected override def runTests(testName : Option[String], reporter : Reporter, stopper : Stopper, filter : Filter, configMap : Map[String, Any], distributor : Option[Distributor], tracker : Tracker) { //
    ensureImplicitFilesRegistered()
    super.runTests(testName, reporter, stopper, filter, configMap,distributor, tracker)
  }

  override def run(testName : Option[String], reporter : Reporter, stopper : Stopper, filter : Filter, configMap : Map[String, Any], distributor : Option[Distributor], tracker : Tracker) {//
    ensureImplicitFilesRegistered()
    super.run(testName,reporter, stopper, filter, configMap, distributor,  tracker)
  }
}
