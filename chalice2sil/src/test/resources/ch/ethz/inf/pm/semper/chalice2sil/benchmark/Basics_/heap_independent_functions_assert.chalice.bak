class Functions {
	function square(x: int): int { x * x }
	
	function div(x: int, y: int): int
		requires y > 0
	{ x / y }
	
	function ternary(b: bool, x: int, y: int): int {
		b ? x : y
	}
	
	/*
	 * Testing function applications with literal arguments
	 */
	
	method literalsCall() {
		assert(square(2) == 4)
		assert(square(-5) == 25)
		assert(square(-5) == 5 * 5)
		
		assert(div(6, 3) == 2)
		assert(div(10, 2) == 5)
		assert(div(11, 2) == 5)
		
		assert(ternary(true, 1, -1) == 1)
		assert(ternary(false, 1, -1) == -1)
	}
	
	method literalsComplexCalls() {
		assert(square(square(-2)) == 16)
		assert(square(-10) == square(10))
		assert(square(div(25, square(5))) == square(square(square(1))))
		
		assert(ternary(square(0) == div(1,2), 1, -1) == div(2,2))
		assert(ternary(square(-1) != div(3,2), 1, -1) == -div(square(5),square(-5)))
	}
	
	method failLiteralsCallSquare() {
		assert(square(2) == 3) /* @Error 410 */
	}

	method failLiteralsCallDiv() {
		assert(div(11, 3) != 3) /* @Error 410 */
	}	
	
	method failLiteralsCallTernary() {
		assert(ternary(true, 11, 3) == 3) /* @Error 410 */
	}
	
	method failLiteralsComplexCalls1() {
		assert(square(square(-2)) == 8) /* @Error 410 */
	}
	
	method failLiteralsComplexCalls2() {
		assert(square(-10) != square(10)) /* @Error 410 */
	}
	
	method failLiteralsComplexCalls3() {
		assert(square(div(-25, square(5))) == -square(square(square(1)))) /* @Error 410 */
	}
	
	method failLiteralsComplexCalls4() {
		assert(ternary(square(0) == div(1,2), -1, 1) == div(2,2)) /* @Error 410 */
	}
	
	method failLiteralsComplexCalls5() {
		assert(ternary(square(-1) != div(3,2), 1, -1) == div(square(5),square(-5))) /* @Error 410 */
	}
	
	/*
	 * Testing function applications with variable arguments
	 */
	
	method argsCallsSquare1(x: int, y: int, z: int)
		requires x == y
		requires z != x && z != 0
	{
		assert(square(x) == square(y))
		assert(square(-x) == square(y))
		assert(square(-x) == square(x))
		assert(square(x) == x * x)		
		assert(square(x) == square(z) ==> x == -z)
		assert(square(z) != 0)
	}
	
	method argsCallsSquare2(x: int, y: int, z: int)
		requires x == y
		requires z != x && z != 0
	{
		var x2: int := x*x
		var y2: int := y*y
		var y3: int := y*y2
		var y4: int := y2*y2
		var z2: int := z*z
		var z4: int := z2*z2
		var z6: int := z2*z2*z2
		var z8: int := z4*z4
		
		assert(square(x + square(y + square(z))) == x2 + 2*x*y2 + 4*x*y*z2 + 2*x*z4 + y4 + 4*y3*z2 + 6*y2*z4 + 4*y*z6 + z8)
	}
	
	method argsCallsDiv(x: int, y: int, z: int)
		requires x == y
		requires x > 0 && z > 0
	{
		// assert(div(x, y) == 1) /* Should verify: Try again with Z3 2.16 */
		assert(div(x, y) == div(y, x))
		assert(div(x, y) != div(-x, y))
		// assert(div(x*z, z) == x) /* Should verify: Try again with Z3 2.16 */
		
		if (x > z) {
			// assert(div(x, z) >= 1) /* Should verify: Try again with Z3 2.16 */
		} else {
			// assert(div(x, z) == 0) /* Should verify: Try again with Z3 2.16 */
		}
	}
	
	method argsComplexCalls(x: int, y: int, z: int)
		requires x == y
		requires z != x && z != 0
	{	
		// assert(x > z && z > 0 ==> div(square(x), square(z)) >= 1) /* Should verify: Try again with Z3 2.16 */
		
		assert(x > z && z > 0 ==> square(x) > square(z))
		assert(x > z && z > 0 ==> square(x + 2) > square(z + div(6, 3)))
		
		assert(ternary(square(x) > square(y), 1, -1) == -square(1))
		
		assert(y > 0 ==> div(x, y) != div(-x, y))
		assert(y > 0 ==> div(x, y) == div(y, x))

		assert(y > 0 ==>
				square(ternary(div(x, y) == div(-x, y), 1, -1)) == 1)

		assert(y > 0 ==>
				square(ternary(div(x, y) == div(-x, y), 1, -1))
					==
				-ternary(div(x, y) == div(y, x), -1, 1))
	}
	
	method failArgsCallsSquare1(x: int, y: int)
		requires x == y
	{ assert(square(x) != square(y)) /* @Error 410 */ }
	
	method failArgsCallsSquare2(x: int, y: int)
		requires x == y
	{ assert(square(-x) != square(y)) /* @Error 410 */ }

	method failArgsCallsSquare3(x: int)
		requires x < 0
	{ assert(square(x) < x) /* @Error 410 */ }

	/* SHOULD fail.
	 * However, Z3 (tested with 2.15, 2.16) is yet not able to always determine 
	 * this, sometimes it works, sometimes Z3 gets stuck and doesn't terminate 
	 * or times out after an eternity.
	 * According to Christoph Wintersteiger this is due to the heuristics that
	 * guide Z3 internally.
	 */
	// method failArgsCallsSquare4(x: int, y: int, z: int)
		// requires x == y
		// requires z != x && z != 0
	// {
		// var x2: int := x*x
		// var y2: int := y*y
		// var y3: int := y*y2
		// // var y4: int := y2*y2	// Correct
		// var y4: int := y3*y2 	// Incorrect
		// var z2: int := z*z
		// var z4: int := z2*z2
		// var z6: int := z2*z2*z2
		// var z8: int := z4*z4
		
		// assert(square(x + square(y + square(z))) == x2 + 2*x*y2 + 4*x*y*z2 + 2*x*z4 + y4 + 4*y3*z2 + 6*y2*z4 + 4*y*z6 + z8) /* @Error 410 */
	// }
	
	method failArgsCallsDiv0(x: int, y: int)
		requires x == y
	{ assert(div(x, y) != 1) /* @Error 210 */ }
	
	method failArgsCallsDiv1(x: int, y: int)
		requires x == y && y > 0
	{ assert(div(x, y) != 1) /* @Error 410 */ }
	
	method failArgsCallsDiv2(x: int, y: int)
		requires x == y && x > 0
	{ assert(div(x, y) != div(y, x)) /* @Error 410 */ }
	
	method failArgsCallsDiv3(x: int, y: int)
		requires y > 0
	{ assert(div(x, y) == div(-x, y)) /* @Error 410 */ }
		
	/* Same here - sometimes Z3 terminates (with the expected result), sometimes
	 * it doesn't.
	 */
	// method failArgsCallsDiv4(x: int, y: int) {		
		// var z: int
		
		// if (y == 0) {
			// z := y + 1
		// } else if (y < 0) {
			// z := -y
		// } else {
			// z := y
		// }
		
		// assert(div(x * z, z) != x) /* @Error 410 */
	// }
	
	method failArgsComplexCalls1(x: int, z: int)
		requires z != x && z != 0
	{	assert(x > z && z > 0 ==> div(square(x), square(z)) > 1) /* @Error 410 */ }

	method failArgsComplexCalls2(x: int, z: int)
	{ assert(x > z ==> square(x) > square(z)) /* @Error 410 */ }
	
	method failArgsComplexCalls3(x: int, y: int)
		requires x == y
	{	assert(ternary(square(x) > square(y), 1, -1) == square(1)) /* @Error 410 */ }
		
	method failArgsComplexCalls4(x: int, y: int)
		requires x == y		
	{ assert(y > 0 ==> div(x, y) == div(-x, y)) /* @Error 410 */ }

	method failArgsComplexCalls5(x: int, y: int)
		requires x == y
	{
		assert(y > 0 ==> /* @Error 410 */
				ternary(div(x, y) == div(-x, y), 1, -1) == 1)
	}
	
	method failArgsComplexCalls6(x: int, y: int)
		requires x == y
	{	
		assert(y > 0 ==> /* @Error 410 */
				square(ternary(div(x, y) == div(-x, y), 1, -1)) 
					==
				ternary(div(x, y) == div(y, x), -1, 1))
	}
}