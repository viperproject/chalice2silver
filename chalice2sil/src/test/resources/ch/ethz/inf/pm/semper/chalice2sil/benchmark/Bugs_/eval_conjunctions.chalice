/* 2011-10-05 MHS
 *   The has been an incompleteness when evaluating expressions such as
 *     i > 0 && f(i)
 *   where f's precondition depends on 'i > 0'. Currently, such expressions
 *   are evaluated in the same path conditions, i.e. the first conjunct is
 *   not assumed to hold before the second conjunct is evaluated.
 *   Hence, evaluating such expressions used to fail.
 *
 * Run
 *  syxc --strictConjunctionEvaluation true 
 * to make assertions fail again.
 */

class EvalConjunctions {
	function f(i: int): int
		requires i > 0
	{ -i }

	method test1() {
		assume forall i in [1..5] :: f(i) < 0
			/* Equivalent to
			 *  forall i: int :: i in [1..5] ==> f(i) < 0
			 * Hence, 'i in [1..5]' is assumed, thus fulfilling f's precondition,
			 * before 'f(i) < 0' is evaluated.
			 */
		
		assume exists i in [1..5] :: 1 <= i && f(i) < 0
			/* Equivalent to
			 *  exists i: int :: i in [1..5] && f(i) < 0
			 * Currently (2011-10-05) 'i in [1..5]' is not assumed before
			 * 'f(i) < 0' is evaluated, which then fails since f's precondition
			 * is not fulfilled.
			 */
	}
	
	method test5(i: int)
		requires 1 <= i && f(i) < 0
			/* Works because the complete assertion is produced, that is, the first
			 * conjunct is produced (thereby assumed), then the second conjunct is
			 * produced.
			 * This is possible since we don't need to 'get' the term the assertion
			 * evaluates to, it is sufficient if it is added (alongside possible 
			 * auxiliary terms) to the path conditions.
			 */
	{}
	
	method test4()
		requires exists i: int :: 1 <= i && f(i) < 0
			/* Fails because when 'exists' is produced, it's complete body is
			 * evaluated. This is a) sufficient as long as the body is pure,
			 * and b) what we need to do in order to get the term resulting from
			 * the evaluation, which we need to create the exists-term.
			 */
	{}
	
	function g(i: int): bool
	{ i > 0 && f(i) > 0 }
	
	method test6() {
		assert g(-1) == false /* Invocation used to fail */
		assert g(1) == false  /* Invocation used to fail */
	}

	method test3() {
		assume exists i: int :: 1 <= i && f(i) < 0
			/* Used to fail */
	}

	method test2() {
		/* All used to fail */
		assume exists i: int :: 1 <= i && i < 5 && f(i) < 0
		assume exists i: int :: i in [1..5] && f(i) < 0
		assume exists i in [1..5] :: f(i) < 0
	}
}