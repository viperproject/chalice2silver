/* [2012-03-21 Malte] Reported by Ivo Colombo. */

class RecursionThroughFunctionsOnly {
  function f(): bool
    { f() } /* Cycles through functions only have been detected before. */
}

class OrderedLinkedList {
  var value: int
  var next: OrderedLinkedList

  /* The problem was as follows:
   *  - producing valid's body includes evaluating next.val()
   *  - evaluating next.val() includes producing valid's body
   *  - since the closed-list of visited functions wasn't passed on by
   *    produce, only by eval, val() was always only contained once
   *  - ==> infinite recursion
   *
   * Instead of adding the closed-list to the signature of produce,
   * it is now maintained by the context, which is passed on by all
   * operations.
   */

  predicate valid {
    acc(value) && acc(next) && (next != null ==> next.valid && next.val())
  }

  function val(): bool
    requires valid
  {
    unfolding valid in true
  }
}

class Client {
  method client() {
    var xs: OrderedLinkedList := new OrderedLinkedList
    
    xs.next := null
    
    fold xs.valid
  }
}