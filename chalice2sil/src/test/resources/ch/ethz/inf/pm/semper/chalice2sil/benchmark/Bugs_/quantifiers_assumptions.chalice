/* There have been two bugs in the symbolic execution of SeqQuantifications:
 * 1) Assumptions about the quantified variables, here i >= 1 && i < a, were
 *    not present when the quantification body was evaluated. Hence, the
 *    invocation of f(i) would fail because it was unknown that i >= 0.
 */
/*
 * 2) First, remember that pure functions are not axiomatised by Syxc. Instead,
 *    the relation 'FApp == FBody' is added to the path conditions each time
 *    a function is applied. This also happened when a function application
 *    occurred in a quantification body.
 *    This, however, is not sufficient; the relation has to be part of the
 *    quantification body's guard.
 */ 
/*    Previously, the resulting proof obligation roughly looked like this
 *      σ ∧ f(i) == i  ⊢ ∀ i • 1 <= i < a ==> f(i) >= i
 *    which failed. Now it looks like this
 *      σ ⊢ ∀ i • f(i) == i ∧ 1 <= i < a ==> f(i) >= i
 *    which holds.
 */
class Test {
	method succeed1(a: int)
		requires a > 1
		ensures forall i in [1..a] :: f(i) == i
		ensures forall i in [1..a] :: f(i) >= i		
	{}
	
	method fail1(a: int)
		requires a > 1
		ensures forall i in [1..a] :: f(i) < i/2 /* @Error 310 */
	{}
	
	function f(i: int): int
		requires i >= 0
	{ i }
	
	method succeed2(a: int)
		requires a > 1
		ensures forall i in [a..2*f(a)] :: f(i) > g(i)
		ensures forall i in [a..2*f(a)] :: -f(i) < -g(i)
	{}
	
	method fail2(a: int)
		requires a > 1
		ensures forall i in [a..2*f(a)] :: -f(i) < g(i) /* @Error 310 */
	{}	
	
	function g(i: int): int
	{ i * neg(i) }
	
	function neg(i: int): int
	{ -i }
	
	method test3() {
		assert forall j in [1..5] :: neg2(-j) > 0
		// assert forall j in [5..1] :: neg2(-j) > 0
			/* TODO: 2011-10-03 MHS
			 *       Used to be ok, but after changes in the evaluation of
			 *       quantifiers and after introducing simplifying terms such as 
			 *       terms.Implies and terms.Ite Syxc gets stuck on this assertion.
			 *       However, this is probably not a problem since decreasing
			 *       sequences are (should) not (be) allowed anyway.
			 */
		assert forall j in [0..1] :: neg2(j) == j /* @Error 210 */
	}
	
	function neg2(i: int): int
		requires i < 0
	{ -i }
}