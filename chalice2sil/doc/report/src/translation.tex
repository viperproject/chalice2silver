% !TEX TS-program = xelatex
% !TEX encoding = UTF-8
% !TEX root = ../chalice2sil_report_klauserc.tex

\section{Translation of Chalice}\label{sct:trans}

\begin{sketch}
High-level overview + including focus areas
\end{sketch}

\subsection{Fractional Read Permissions}\label{sct:frp}
To SIL, permission amounts are just another data type. 
The SIL prelude only defines a set of constructors (such as no permission, full permission) and some operators and predicates (such as permission addition, subtraction, equality, comparison). 
In particular, it does not specify how permissions are represented. 
This aligns well with the abstract nature in which fractional permissions are written by the programmer.
As with previous verification backends for Chalice, concrete permission amounts associated with fractional read permissions (\lstinline!acc(x.f,rd)!) are never chosen but only constrained. 
This also means that two textual occurrences of \lstinline!acc(x.f,rd)! in different parts generally do not represent the same amount of permission.

Not choosing a fixed permission amount for abstract read permissions makes them very flexible.
As long as a thread holds any positive amount of permission to a location, we know that we can give away a smaller fraction to a second thread and thereby enable both threads to read that location.
Unfortunately, that amount of flexibility would also make fractional read permissions very hard to use, since every mention of a read permission could theoretically refer to a different amount of permission.
Chalice, therefore, imposes additional constraints on fractional permissions involved in method contracts, predicates, and monitors.
In the following sections we will describe how Chalice2SIL handles each of these situations.

\subsubsection{Methods and fractional permissions}\label{sct:meth}
In Chalice programs, a very common pattern is that a method ``borrows'' permissions to a set of locations, performs its work and then returns the same amount of permission to the method's caller.
In order to readily support this scenario, the original implementation of fractional permissions in Chalice constrains the various fractions mentioned in a method's pre- and postcondition to a value that is chosen once per call site.

\begin{lstlisting}[float,label=lst:actorref,caption={A call that uses and preserves fractional read permissions.},language=Chalice]
class Actor {
	method main(a : int) returns (r : Register)
		ensures r != null
		ensures acc(r.val)
		ensures t.val == a
	{
		r := new Register;
		r.val := 5;
		call act(r);
		r.val := a; //should still have write access here
	}

	method act(r : Register)
		requires r != null
		requires acc(r.val,rd)
		ensures acc(r.val,rd)
	{ /* ... */ }
}
class Register {
	var val : int;
}
\end{lstlisting}

For verifying the callee in listing \ref{lst:actorref}, the Boogie-based implementation introduces a fresh variable permission variable $k_m$, constrains it to be a read-permission ($0<k_m<\text{full}$) and uses it in pre- and postconditions whenever it encounters the abstract permission amount \lstinline!rd!. 

\begin{lstlisting}[float,caption={Handling of fractional read permissions by the Boogie-based Chalice verifier.},label=lst:fraccalleeb]
procedure act(r : Register)
{
	var k_m;
	assume (0 < k_m) && (k_m < Permission$FullFraction);
	// inhale (precondition), using k_m for rd
	...
	// exhale (postcondition), using k_m for rd
}
\end{lstlisting}

Notice how the Boogie-based encoding of Chalice in listing \ref{lst:fraccalleeb} does not make use of the pre- and postcondition mechanism provided by Boogie. 
This is primarily because Boogie does not have a concept of inhaling and exhaling of permissions. 
Not so with SIL, which features pre- and postconditions that are aware of access predicates. 
Conceptually, when you ``call'' a method in SIL, the precondition is properly exhaled and the postcondition inhaled afterwards.

However, using SIL preconditions also means that we can't just make up a new variable $k_m$, instead it becomes a ``ghost'' parameter and introduces an additional precondition. This makes a lot of sense, since the value $k_m$ is always specific to one call of a method.

In the actual Boogie-based encoding, the upper bound on \lstinline!k_m! is even lower to give the programmer more flexibility. 
Currently, \lstinline!k_m! is assumed to be smaller than a thousandth of \lstinline[language=Chalice]!1%!.
This allows the programmer to for instance specify a method that requires \lstinline[language=Chalice]!acc(x.f,rd)! twice, effectively demanding at least \lstinline!2*k_m! permission to \lstinline!x.f!.
The exact ratio was chosen arbitrarily and could always be lowered, but has so far worked well for most examples.

\begin{lstlisting}[float,caption={Handling of fractional read permissions by the Chalice2SIL translator},label=lst:fraccallees,language=SIL]
method Actor::act(r : Register, k_m : Permission)
	requires 0 < k_m && k_m < write
	requires r != null
	requires acc(r.val, k_m)
	ensures acc(r.val, k_m)
{ … }
\end{lstlisting}

\subsubsection{Method calls with fractional permissions}\label{sct:methcall}
Without fractional permissions, synchronously calling a method in SIL is as simple as using the built-in call statement:

\begin{lstlisting}[language=SIL]
call () := Actor::act(r)
\end{lstlisting}

SIL takes care of asserting the precondition, exhaling the associated permissions, havocing the necessary heap locations, inhaling the permissions mentioned by the postcondition and finally assuming said postcondition. Adding support for fractional read permissions now only means providing a call-site specific value $k$, right? 

Unfortunately, this where the high-level nature of SIL becomes an obstruction. 
For each method call-site, we want to introduce a fresh variable $k_c$ that represents the fractional permission amount of permission selected for that particular call. 
Then, we want to constrain it to be smaller than the amount of permissions we hold to each of the locations mentioned with abstract read permissions (\lstinline!rd!). For the simple preconditions above, this is easy to accomplish:

\begin{lstlisting}[language=SIL]
var k_c : Permission;
assume k_c < perm(r.val);
call () := Actor::act(r,k_c);
\end{lstlisting}

The term \lstinline!perm(r.val)! is a native SIL term that represents the amount permission the current thread holds to a particular location. 
Sadly, this simple scheme breaks down when we have to deal with multiple instances of access predicates to the same location.

Chalice dictates that
\begin{lstlisting}[language=SIL]
exhale acc(x.f,rd) && acc(x.f,rd)
\end{lstlisting}
is to be treated as
\begin{lstlisting}[language=SIL]
exhale acc(x.f,rd)
exhale acc(x.f,rd)
\end{lstlisting}

Both exhale statements cause $k_c$ to be constrained to the amount of permission held to $x.f$. 
Since exhale has the “side-effect” of giving away the mentioned permissions, this $k_c$ will be constrained further by the second exhale statement.

Additionally, access predicates can be guarded by implications. 
In that case, the Boogie-based Chalice implementation translates 
\begin{lstlisting}[language=Chalice]
exhale P ==> acc(x.f, rd) 
\end{lstlisting}
as
\begin{lstlisting}[language=Chalice]
if(P) 
{ 
	exhale acc(x.f, rd);
}
\end{lstlisting}

At this point we could have decided not to use SIL's built-in call statement and instead encode synchronous method calls as a series of exhale statements, followed by inhaling the callee's postcondition. 
While that would have been equivalent from a verification perspective, we would still be throwing away information: the original program's call graph.

In order to still use SIL's call statement, we need to keep track of the “remaining” permissions while constraining $k_c$ without actually giving away these permissions, otherwise the verification of the call statement would fail. 
We cannot simply create a copy of the permission mask as a whole and have exhale operate on that instead. 
SIL at least allows us to look up individual entries of the permission mask via the \lstinline!perm(x.f)! term. 
We use that ability to manually create and maintain a permission map of our own. 

Like the permission mask in the Boogie-encoding of Chalice, this data structure must map heap locations, represented as pairs of an object reference and a field identifier, to permission amounts. 
At this time, SIL has no reified field identifiers. 
So in order to distinguish locations (pair of an object reference and a field), the Chalice2SIL translator assigns a unique integer number to each field in the program. 

The only way to populate this map, is to ``copy'' the current state of the actual permission mask entry by entry via the \lstinline!perm(x.f)! term. 
Unfortunately, we can't do this in one big ``initialization'' block, since some of the object reference expressions that occur on the right-hand-side of implications might not be defined outside of that implication. 

We could expand implications in the precondition twice: once for initializing our permission map, and once to actually simulate the exhales and constraining of $k_c$, but there is a more concise way.

We start out with two fresh map variables $m$ and $m_0$. The former, $m$, is the permission map we are going to update while constraining $k_c$, whereas $m_0$ represents the state of the permission map immediately before the method call. 
We let the SIL verifier assume that the two maps are identical initially and later add more information about $m$'s initial state by providing assumptions about $m_0$.

\begin{lstlisting}[language=sil,float,caption={Translation sketch for a method call involving fractional read permissions and the precondition \lstinline:acc(r.val,rd) && p ==> acc(r.val):},label=lst:rdcall]
var k_c : Permission
var m : Map[Pair[ref, Integer], Permission];
var m_0 : Map[Pair[ref, Integer], Permission];
assume 0 < k_c && 1000*k_c < k_m;
assume m == m_0;
// acc(r.val,rd)
assume m_0[(r,1)] == perm(r.val);
assert 0 < m[(r,1)];
assume k_c < m[(r,1)];
m[(r,1)] := m[(r,1)] - k_c;
// p ==> acc(r.val,rd)
if(p){
	assume m_0[(r,1)] == perm(r.val);
	assert 0 < m[(r,1)];
	assume k_c < m[(r,1)];
	m[(r,1)] := m[(r,1)] - k_c;
}
// finally, the actual call
call () := m(r,p,k_c);
\end{lstlisting}

After $k_c$ is sufficiently constrained, we just emit a call to our target method. 
The SIL verifier will have to 
	exhale the precondition (giving away the permissions it mentions), 
	havoc heap locations that the caller has lost all permissions to, 
	then inhale the postcondition (receiving permissions it mentions) 
	and finally assign results to local variables as necessary.

\begin{figure}
\begin{align*}
	k_m &: \text{read fraction selected for the surrounding scope} \\
	e &: \text{terms} \\
	P,Q &: \text{expressions} \\
	p,q 	&: \text{permission amount} \\
	f 	&: \text{field} \\
	n 	&: \text{integer} \\
	g 	&: \text{function} \\
	G 	&: \text{precondition of $g$} \\
	x_1,\dotsc,x_n &: \text{parameters of $g$} \\
	m[e] &: \text{look up map entry with key $e$ in map $m$} \\
	P[x/e] &: \text{$P$, but with $e$ substituted for $x$}
\end{align*}
\caption{Meaning of names used below.}
\end{figure}

\begin{figure}
\begin{align*}
	H(p * q,h) 	&= H(p,h) \land H(q,h) \\
	H(p + q,h) 	&= H(p,h) \land H(q,h) \\
	H(p - q,h) 	&= H(p,h) \land H(q,¬h) \\
	H(p * n,h) 	&= H(p,h) \\
	H(k_m,h)		&= ¬h \\
	H(\_,h) &= \text{false}
\end{align*}
\caption{Helper function that determines whether a permission amount expression can be used to constrain $k_c$.}
\end{figure}

\begin{figure}
\begin{align*}
	E\ch{\acc{e.f,p}} &= \sil{\text{\lstinline[language=SIL]!perm!}\left(E\ch{e},f\right) < E\ch{p}} \\
	E\ch{e} &\text{ translates expression $e$ to SIL terms and expressions} \\
	\begin{split}
	R\ch{P} &= \openSIL{\vphantom{\ch{P}}} \\
		&\text{\lstinline[language=SIL]!var! } k_c,m,m_0 \semicolon\\
		&\inhale{0 < k_c \land k_c*1000 < k_m}\semicolon \\
		&\inhale{m = m_0}\semicolon \\
		& \closeSIL{T\ch{P}}
	\end{split} \\
	T\ch{P \land Q} &= \sil{T\ch{P}\text{\lstinline!; !}\ T\ch{Q}} \\
	T\ch{e ⇒ Q} &= \sil{\text{\lstinline[language=Chalice]!if!}\left(E\ch{e}\right) \left\{ T\ch{Q} \right\}}	 \\
	\begin{split}
	T\ch{\acc{x.f,p}} &= \text{if}\; H(E\ch{p},\text{false})\quad \openSIL{ \vphantom{\ch{P}} } \\
										&\exhale{D\ch{x}} \semicolon \\
										&\inhale{m_0\left[\left(E\ch{x},f\right)\right] = \text{\lstinline[language=SIL]!perm!}\left(E\ch{e},f\right) \semicolon} \\
										&\exhale{0 < m\left[\left(E\ch{x},f\right)\right]} \semicolon \\
										&\inhale{E\ch{p} < m\left[\left(E\ch{x},f\right)\right]} \semicolon \\
										&\closeSIL{m\left[\left(E\ch{x},f\right)\right] := m\left[\left(E\ch{x},f\right)\right] - E\ch{p}}
	\end{split} \\
	T\ch{\acc{x.f,p}} &= \text{otherwise}\quad \sil{ \text{\lstinline!skip!} }
\end{align*}
\caption{Translation schemes. $R$ generates code that constrains a fresh $k_c$ according to the method precondition/loop invariant $P$. $T$ recursively translates $P$ to constraint $k_c$. $D\ch{x}$ determines whether $x$ is well-defined. See figure \ref{fig:trans.definedness}.}
\end{figure}

\subsection{Asynchronous method calls (Fork-Join)}\label{sct:fj}
At this time, SIL only provides synchronous call statements. 
We therefore have to fall back to just exhaling the precondition on fork and inhaling the postcondition on join. 
The challenging aspect of verifying asynchronous method calls is establishing the link between a join and the corresponding fork.
Old expressions, in particular, are difficult to capture in SIL without a dedicated call statement.

\subsubsection{Translation of \lstinline!fork!}\label{sct:fjfork}

The translation of the Chalice \lstinline!fork! statement seems, at least at first, relatively straightforward: exhale the method's precondition and create a token object with a boolean field called ``\lstinline!joinable!'' set to \lstinline!true!.
But how would we then translate the corresponding \lstinline!join! statement(s)? The method's postcondition is formulated in terms of the method's return values and parameters.
In general we no longer have access to the latter.
The \lstinline!join! might happen in a different method, but even if it occurs in the same method as the \lstinline!fork!, the heap and the values of local variables could have changed in the meantime.
Ideally, we could somehow capture the entire program state and store it in or associate it with the token at the \lstinline!fork! statement.
At the \lstinline!join! statement, we would then evaluate (inhale) the method's postcondition in terms of that program state.

Sadly, SIL currently has no such mechanism. 
It does have \lstinline[language=SIL]!old! expressions but they are hardwired to refer to the pre-state of the surrounding method (the state immediately prior to a call to that method).
Fortunately, we don't actually need to capture the entire program heap. 
The set of values that might be missing at the \lstinline!join! site are the arguments and the values of old expressions. 
Since this includes at most all arguments and old expression, we can generate a ghost field on the token to ``transport'' each of values from the \lstinline!fork! site to the \lstinline!join! site.

Chalice2SIL generates one ghost field for each method argument and one ghost field for each \lstinline!old! expression in the method's postcondition. 
Just before the \lstinline!exhale! statement of a \lstinline!join!, it assigns the effective arguments to the argument ghost fields of the token. It then evaluates the old expressions of the method's postcondition and assigns the results to the corresponding ghost fields. 

There is just one more complication to take care of: \lstinline!old! expressions can appear on the right-hand-side of implications, where they might only be defined part of the time (missing permissions and null references). 
Unfortunately, just expanding implications into if-statements, like we did when constraining $k_c$, is not an option because the left-hand-side of the implication could be a return value, which is of course only available at the \lstinline!join! site.
Instead, we walk over each \lstinline!old! expression and generate a set of conditions that need to be satisfied for the expression to be defined at the \lstinline!fork! site. 

\begin{figure}
\begin{align*}
	D\ch{P ⇒ Q} &= \sil{D\ch{P} \land \left(E\ch{P} ⇒ D\ch{Q}\right)} \\
	\begin{split}
		D\ch{\text{\lstinline[language=Chalice]!if!}\left(e\right)\ P\ \text{\lstinline[language=Chalice]!else! } Q} &= 
		\openSIL{D\ch{e} \land \left(E\ch{e} ⇒ D\ch{P}\right)} \\
		&\closeSIL{\qquad\land\left(¬E\ch{e} ⇒ D\ch{Q}\right)}
	\end{split} \\
	\begin{split}
	D\ch{e.f} &= \openSIL{D\ch{e} \land ¬\left(E\ch{e} = \text{\lstinline!null!}\right)} \\
						&\closeSIL{\qquad \land\; 0 < \text{\lstinline[language=SIL]!perm!}\left(E\ch{e},f\right)}
	\end{split} \\
	\begin{split}
	D\ch{e.g\left(a_1, \dotsc, a_n\right)} &= \openSIL{D\ch{e} \land ¬\left(E\ch{e} = \text{\lstinline[language=Chalice]!null!}\right)} \\
						&\closeSIL{\qquad \land\; E\ch{G\left[\text{\lstinline[language=Chalice]!this!}/e,x_1/a_1,\dotsc,x_n/a_n\right]}}
	\end{split}
\end{align*}
\caption{Translation scheme for ensuring the definedness of an expression.}\label{fig:trans.definedness}
\end{figure}

\begin{sketch}
Need to mention that $k_c$ is computed in exactly the same way as for synchronous calls?
\end{sketch}

\begin{lstlisting}[float,caption={Example of Chalice program featuring fork and join of method with a possibly undefined \lstinline!old! expression.},label=lst:fjexample,language=chalice,numbers=left]
class Cell { var f : int; }
class SuperCell { var cell : Cell; }

class Main {
    method parallel(d : SuperCell) returns (r: bool)
        requires d != null ==> acc(d.cell, rd) && d.cell != null 
				                    && acc(d.cell.f, rd) && d.cell.f == 5
        ensures r == (d != null)
        ensures r ==> old(d.cell.f == 5)
        ensures r ==> (acc(d.cell, rd) && acc(d.cell.f, rd))
    {
          r := d != null;
    }

    method main(d : SuperCell, c : Cell)
        requires acc(d.cell) && acc(c.f)
        ensures acc(d.cell) && acc(c.f)
    {
        var r : bool;
        d.cell := c;
        c.f := 5;
        fork tk := parallel(d)
        assert c.f == 5; // still have read-access
        join r := tk;
        assert r;
    }
}
\end{lstlisting}

\begin{lstlisting}[float,caption={Translation of the \lstinline!fork! statement on line 22 in listing \ref{lst:fjexample}.},label=lst:fjexamplefork,language=sil]
var tk : ref;
tk := new ref;
inhale acc(tk.joinable,write);
tk.joinable := true;
// constrain k_c, the read fraction for this call 
...
// store arguments in token
inhale acc(tk.this,write);
tk.this := this;
inhale acc(tk.d,write);
tk.d := d;
inhale acc(tk.k_m,write);
tk.k_m := k_c;
//store old values in token
inhale acc(tk.old1,write);
if(d != null && 0 < perm(d.cell) && d.cell != null && 0 < perm(d.cell.f)){
	tk.old1 := (d.cell.f == 5);
}
// "perform" the asynchronous call by exhaling the callee's precondition
exhale this != null && 0 < k_c && k_c < write &&
       d != null ==> acc(d.cell, k_c) && d.cell != null 
				          && acc(d.cell.f, k_c) && d.cell.f == 5
\end{lstlisting}
 
\subsubsection{Translation of \lstinline!join!}\label{sct:fjjoin}
With most of the hard work done when the thread was forked, the translation of a \lstinline!join! statement is relatively straightforward.
First, we must assert that the token is still \lstinline!joinable! (we also need write-access to that field in order to set it to false). 
Then we inhale the method's postcondition using the ghost fields on the token as substitutions for the arguments and old expressions. 
Finally, we have to assign the results of the asynchronous computation to the variables indicated by the Chalice programmer.

A detail worth mentioning is the representation of results for the \lstinline!inhale! statement. 
Chalice2SIL also creates ghost fields on the token for results. 
Since a token is only ever joined once, we can safely inhale the permissions to access those result fields. 
Conceptually, by joining with the current thread, the forked thread transfers access to its results along with all other permissions from its postcondition.

Alternatively, we could have used fresh local variables to represent result values. The only advantage that ghost fields provide, is that we \emph{don't} need to introduce new variables.

\begin{lstlisting}[float,caption={Translation of the \lstinline!join! statement on line 24 in listing \ref{lst:fjexample}.},label=lst:fjexamplejoin,language=sil]
exhale tk.joinable // SIL verifier also needs to assert that tk != null
inhale acc(tk.r,write) && tk.r == (tk.d != null)
   &&  tk.r ==> tk.old1
   &&  tk.r ==> acc(tk.d.cell, tk.k_m) && acc(tk.d.cell.f, tk.k_m);
r := tk.r;
tk.joinable := false;
\end{lstlisting}

\begin{figure}
\begin{align*}
\begin{split}
	F\ch{\text{\lstinline[language=Chalice]!old!}\left(e\right)} &= \openSIL{ \vphantom{\ch{P}} } \\
		& \inhale{\acc{t.f_e,\text{\lstinline!write!}}} \\
		& \text{\lstinline[language=Chalice]!if!}\left(D\ch{e}\right) \{ \\
		& \quad t.f_e := E\ch{e} \\
		& \}
\end{split} \\
F\ch{P} &= \text{descend into $P$ to find all \lstinline[language=Chalice]!old! expressions and terms}
\end{align*}
\caption{Assign \lstinline[language=Chalice]!old!$(e)$ value to its own field $f_e$, if $e$ is defined.}
\end{figure}

The accessibility of all the other ghost fields on the token requires a bit more work. 
Naturally, tokens can also be passed to other threads and joined there. 
The requirement that the joining thread has exclusive access to the \lstinline!joinable! field ensures that only one thread can join on a given token. 
Now, while the ghost fields on the token might be invisible to the Chalice programmer, SIL does not distinguish between ghost fields and ordinary fields in any way.
We need to make sure that every method that tries to access any of the ghost fields actually has permissions to do so.

Fortunately, ghost fields on a token are only accessed when we also have permission to access the \lstinline!joinable! field on that token and it is the Chalice programmer's burden to ensure that a thread has this permission when attempting to join on a token. 
If we could somehow link the amount of permission a thread has to each of the ghost fields to the amount of permission it holds to \lstinline!joinable!, we would always end up with a sufficient amount of permission for the ghost fields.

While SIL provides no built-in support for linking fields together accessibility-wise, we can achieve a similar effect by translating every accessibility predicate for \lstinline!joinable! as an accessibility predicate for that \emph{and} all ghost fields (with the same amount of permission for each). That way, we can be sure that whenever a thread holds full permissions to a \lstinline!joinable! field, it also holds full permissions to all ghost fields on the token. More formally, given a token $t$, a permission amount $p$, ghost fields $a_1 \cdots a_k$ (the arguments) and $o_1 \cdots o_n$ (evaluated old expressions), we apply the following transformation:

\begin{align*}
	&\sil{\acc{t.\text{\lstinline!joinable!, p}}} \\
	&\qquad\text{becomes}\qquad \\
	&\left\ldbrack\acc{t.\text{\lstinline!joinable!}, p} \land \acc{t.\text{\lstinline!this!}, p}\ \land \right. \\
  &\land\ \acc{t.a_1, p} \land \acc{t.a_2, p} \land \cdots \land \acc{t.a_k, p}\ \land \\ 
	&\left. \land\ \acc{t.o_1, p} \land \acc{t.o_2, p} \cdots \acc{t.o_n} \right\rdbrack_{\text{SIL}}
\end{align*}

\subsubsection{Limitations of the current fork-join implementation}\label{sct:fjlimits}
Joining a thread seems deceptively simple when done in the same method the thread was originally forked from. 
This is because the verifier has seen the assignments to the token ghost fields first hand. 
When a thread is joined in a separate method, however, that context is not available because both Silicon and the Boogie-based implementation verify each method in complete isolation.

For just joining a thread in a separate method, the programmer needs to pass both the token and write access to the token's \lstinline!joinable! field to the method that performs the joining 
and ensure that the thread has not been joined already.
Unfortunately, the postcondition of an asynchronous method call joined this way is next to useless, because the verifier has no information about the context of the method call. 
Specifically, the verifier doesn't know anything about the receiver or any of the arguments originally passed to the thread. 
As a consequence, any clause of the postcondition that mentions the \lstinline!this! pointer or an argument is useless to the verifier.

\begin{lstlisting}[float,caption={Limitations with joining in separate methods},label=lst:joinseparatethis,language=chalice]
class Main{
    var f : int;
    method work()
        requires acc(this.f)
        ensures acc(this.f)
    {
    }

    method main()
        requires acc(this.f)
        ensures acc(this.f)
    {
        fork tk := work();
        call client(tk, this);
    }

    method client(tk : token<Main.work>, obj : Main)
        requires acc(tk.joinable) && tk.joinable
        ensures acc(obj.f) // might not hold
    {
        join tk;
    }
}
\end{lstlisting}

Listing \ref{lst:joinseparatethis} demonstrates a simple program that fails to verify because the context of the forked thread is lost when the token is transferred to the callee (\lstinline!client!). 
The verifier will complain that there might not be enough permission to satisfy \lstinline!acc(obj.f)!, because it doesn't know that the \lstinline!this! pointer used to call \lstinline!work! refers to the same object as \lstinline!obj!.
We would like to tell the verifier more about how our token was created. 

\begin{lstlisting}[language=chalice]
        requires tk.thisPtr == obj //not valid Chalice expression
\end{lstlisting}

While the previous example is not valid Chalice code, there is a mechanism that can be used to create similar specifications. Listing \ref{lst:joineval} shows how the \lstinline!eval! expression can be used to provide the verifier with the information necessary to prove that the method satisfies its postcondition. 

\begin{lstlisting}[float,caption={\lstinline!eval! expression in Chalice},label=lst:joineval,language=chalice]
method client(tk : token<Main.work>, obj : Main)
        requires acc(tk.joinable) && tk.joinable
        requires eval(tk.fork this.work(), this == obj)
        ensures acc(obj.f)
    { join tk; }
\end{lstlisting}

An $\ch{\text{\lstinline!eval!}\left(r.a, e\right)}$ expression consists of three parts: the ``context'' $c$ (the token in our case), the description of the ``\emph{eval state}'' $a$ and an expression $e$ to be evaluated in that state. In our case, we specify a ``\emph{call state}'' of the form $\ch{\text{\lstinline!fork!}\ r.m\left(a_1, a_2, \cdots, a_k\right)}$. 
Here $r$ denotes the receiver of the asynchronous method call, $m$ is the name of the method called and $a_i$ stand for the arguments originally passed to the method.

Chalice2SIL supports a very limited form of the \lstinline[language=Chalice]!eval! expression which covers exactly the use-case outlined above. 
As long as the \lstinline[language=Chalice]!eval! expression binds to a \lstinline[language=Chalice]!fork! token and has \lstinline[language=Chalice]!true! as its second operand $e$, Chalice2SIL translates it as follows:

\begin{align*}
	V\ch{\text{\lstinline[language=Chalice]!eval!}(t.\text{\lstinline[language=Chalice]!fork!}\ \ r.m(a_1, a_2, \cdots, a_k), \text{\lstinline[language=Chalice]!true!})} &= \openSIL{} E\ch{t} \neq \text{\lstinline[language=SIL]!null!}  \\ 
	&\ \land E\ch{t}.\text{\lstinline!this!} = E\ch{r} \\ 
	&\ \land E\ch{t}.a_1 = E\ch{a_1} \\ 
	&\qquad \vdots \\
	&\left.\ \land E\ch{t}.a_k = E\ch{a_k} \right\rdbrack_\text{SIL}
\end{align*}

This small extension is just expressive enough to associate tokens with parts of the context they were forked from, allowing the joining method to actually take advantage of the postcondition of the forked method.

\subsection{Predicates and Functions}\label{sct:pf}
Predicates and functions were part of SIL since its inception, in a form that very much resembles the functions and predicates from Chalice. 
As a result, the translation of functions and predicates from Chalice to SIL is relatively straightforward. 

\subsubsection{Predicates}

In contrast to abstract fractional read permissions in methods (\lstinline[language=Chalice]!rd!), which can assume a different value for each invocation, the fraction used in predicates remains fixed. 
This is essential to ensure that the predicate holds the same amount of permission regardless of where it was folded. 
Otherwise the user would have to specify exactly how much permission a predicate contains, which rather defeats the purpose of predicates (information hiding).

Abstract read permissions mentioned in predicates are thus fixed.
To implement this, we define an uninterpreted constant function \lstinline[language=SIL]!globalPredicateReadFraction()! and declare that this global read fraction is strictly positive and less than full/write permission.

It is possible that, in the future, we'd like to have different fractions for different predicates or even different fractions for each combination of object (this-pointer) and predicate. 
To support this scenario, we don't insert references to \lstinline[language=SIL]!globalPredicateReadFraction()! directly into the generated SIL program and instead use an intermediate function \lstinline[language=SIL]!predicateReadFraction(int,ref)!, also uninterpreted.
Analogously to the ``field identifiers'' that we used to index into our copy of the permission mask when we constrain the read permission fraction for method calls, we generate unique ``predicate identifiers'' to distinguish between different predicates on the same object.
However, at the moment every SIL program that Chalice2SIL generates also contains an axiom that makes predicate read fractions effectively global:
\[
	\forall i,r.\ \ \text{\lstinline!predicateReadFraction(i,r)!}\ =\ \text{\lstinline!globalPredicateReadFraction()!}
\]
This constraint makes it easier to transfer abstract read permissions between predicates, giving \lstinline[language=Chalice]!acc(x.f,rd)! a fixed meaning across all predicates. 
Outside of predicates, the user can refer to the same amount of permission by explicitly mentioning the predicate in an argument to the abstract read permission. 
Given two object references $x$ and $y$, a field $f$, a predicate $p$ and a corresponding predicate identifier $i_p$, Chalice2SIL translates an accessibility predicate that involves an abstract read fractions for predicates as follows:
\begin{align*}
	\ch{\acc{x.f,\text{\lstinline[language=Chalice]!rd!}(y.p)}} &= \sil{\acc{E\ch{x.f}, \text{\lstinline!predicateReadFraction!}(i_p,E\ch{y})}}
\end{align*}

\subsubsection{Functions}
Ideally, we would want to encode abstract read permissions in functions the same way we encode them when they occur in method pre/postconditions: Constraining a different fraction for each call site.
Unfortunately, the technique we used for read fractions in method calls would not work for function calls, because our solution is based on ``mutating'' a data structure in an imperative fashion. 
Function calls can occur in method pre/postconditions and even inside other function bodies.
All of those contexts are pure, and thereby inherently incompatible with how abstract read permission fractions are fixed for method calls.

But functions being pure also gives us more freedom since we don't have to make the distinction between read permissions and read-write permissions (functions aren't allowed to modify the heap anyway). 
Similarly, as functions always automatically return the same amount of permission that they received, it doesn't really matter exactly ``how much'' permission a function has, only to which heap locations it has access.
As a  result, Chalice2SIL translates permissions in function preconditions as \lstinline[language=Chalice]!rd*!, which means ``any read-permission''.
\[
	\ch{\acc{x.f, rd*}}\ =\ \sil{\exists a, 0 < a < \text{\lstinline!write!}.\ \ \acc{x.f,a}}
\]

\subsection{Monitors with Deadlock Avoidance}\label{sct:mon}
As with predicates, the permissions stored in a monitor need to be fixed and cannot be chosen every time we lock over an object. 
Otherwise we'd have to track what amount of permission the monitor holds onto at any point in the program. 
So, as with predicates, we define an uninterpreted function that represents the fraction of permission that the verifier uses whenever it encounters an abstract fractional read permission in a monitor.
To make mixing monitors and predicates easier, we use the same global fraction for monitors as we used for predicates.

The really difficult part, however, is the implementation of the locking and deadlock prevention itself.  
In this section we present our partial solution in the hope that it will help in finding a working implementation of deadlock avoidance in SIL, or failing that, in the hope that it at least serves as a demonstration of the limits of SIL.

\subsubsection{Deadlock Prevention and Locking}
For locking and deadlock prevention we need to add two kinds of information to each object: a boolean indicating whether the object in question is locked and a \emph{mu} value that indicates the object's position in the locking order.
To recapitulate, mu values are part of the partially ordered set \emph{$(Mu,\ll)$}.
Only one concrete value exists: \emph{lockbottom}, the single smallest element of Mu. All other values of Mu are kept abstract and only described in terms of their $\ll$-relation to one another. 

The key idea behind deadlock prevention in Chalice, that a thread can only acquire a lock on monitor/object $m$ if it is clear that that monitor/object is higher in the locking order than any other monitor that that thread already has a lock on.
In more concrete terms, locking is allowed when $\forall o \in \text{objects}.\ \ o=m \lor ¬\text{\lstinline[language=Chalice]!holds!}(o) \lor o.\text{\lstinline!mu!} \ll m.mu$.

To use this expression in a SIL assertion (an exhale statement prior to acquiring a lock), we need to make sure that the relevant locations are well defined. 
To ensure that we can access \lstinline!m.mu!, we first check $m \neq \text{\lstinline[language=Chalice]!null!}\ \land\ 0 < \text{\lstinline[language=SIL]!perm!}(m.\text{\lstinline!mu!})$. 
But then we run into the problem that we cannot possibly require access to the \lstinline!mu!-fields on all objects $o$. One could try guard references to $o.\text{\lstinline!mu!}$ with an implication: \[
	0 < \text{\lstinline!perm!}(o.\text{\lstinline!mu!}) \Rightarrow ¬\text{\lstinline!holds!}(o) \lor o.\text{\lstinline!mu!} \ll m.mu
\]
Unfortunately that is not correct. 
While a method needs read-access to the \lstinline!mu! field to acquire the lock on an object $o_1$, it can then give away all permissions to fields of $o_1$ (it could fork a thread and hand complete control over that object to the forked thread), while still holding the lock on the monitor associated with $o_1$.
With the assertion above, temporarily not having any permission to access to $o_1.\text{\lstinline!mu!}$ would allow us to acquire the lock on a monitor that is not higher in the locking order than $o_1$.

We need to associate each object with a \lstinline!mu! and a flag that indicates whether the object's monitor is acquire by the current thread. 
The only mechanism that SIL provides for associating information with an object are fields but using fields is not an option.
The Boogie-based implementation uses additional masks and that is what we will try to emulate in our approach.

We add another hidden parameter to each method, the \lstinline!\$CurrentThread: ref!. 
This object has two fields \lstinline!heldMap! and \lstinline!muMap!, mapping from references to boolean values and from references to mu values, respectively.
Via their preconditions, each method gets to assume the following:
\begin{align*}
 \text{\lstinline!currentThread!} \neq \text{\lstinline!null!}\ &\land\ \acc{\text{\lstinline!currentThread!}.\text{\lstinline!heldMap!},\text{\lstinline!write!}} \\
	&\land\ \acc{\text{\lstinline!currentThread!}.\text{\lstinline!muMap!},\text{\lstinline!write!}}
\end{align*}

However, the \lstinline!mu! field is not an implementation detail of Chalice2SIL or the Boogie-based Chalice verifier, but an actual field that the user of Chalice has to take into consideration when dealing with monitors. 
The greatest challenge is thus to keep what the verifier knows about the \lstinline!muMap! and what it knows about \lstinline!mu! fields in synchrony.
To that end, every occurrence of an accessibility predicate that mentions \lstinline!mu! will be translated according to the following rule:
\[
	\ch{\acc{x.\text{\lstinline!mu!},a}} = \sil{\acc{x.\text{\lstinline!mu!}, a} \land \text{\lstinline!currentThread!}.\text{\lstinline!muMap!}[x] = x.\text{\lstinline!mu!}}
\]
This makes sure that whenever we gain access to an \lstinline!mu! field, we also get a matching entry in the \lstinline!currentThread!'s \text{\lstinline!muMap!}. 
Or, conversely, whenever we give away permission to a \lstinline!mu! field, we must also ensure that the \lstinline!muMap! is up to date.

\begin{sketch}
newobj
\end{sketch}
\begin{sketch}
share
\end{sketch}
\begin{sketch}
 acquire
\end{sketch}
\begin{sketch}
release
\end{sketch}
\begin{sketch}
unshare
\end{sketch}

In the postcondition of each method, we make sure that the \lstinline!mu! and \lstinline!help! maps are in a consistent state.
The programmer uses the \lstinline[language=Chalice]!lockchange! declaration to list all objects it changed the lock state of. 
Without any \lstinline[language=Chalice]!lockchange! declarations, all method postcondition contain the following assertions:
\begin{align*}
	&\acc{\text{\lstinline!currentThread!}.\text{\lstinline!heldMap!},\text{\lstinline[language=SIL]!write!}} \land \acc{\text{\lstinline!currentThread!}.\text{\lstinline!muMap!},\text{\lstinline[language=SIL]!write!}} \\
	&\land\ \forall o_c \in  \text{objects}.\ \ \text{\lstinline[language=Chalice]!old!}\left(\text{\lstinline!currentThread!}.\text{\lstinline!heldMap!}\right)[o_c] = \text{\lstinline!currentThread!}.\text{\lstinline!heldMap!}[o_c] \\
	&\land\ \forall o_d \in \text{objects}.\ \ \left(\text{\lstinline!currentThread!}.\text{\lstinline!heldMap!}[o_d]\right) \Rightarrow \\
	&\qquad \text{\lstinline[language=Chalice]!old!}\left(\text{\lstinline!currentThread!}.\text{\lstinline!muMap!}[o_d]\right) = \text{\lstinline!currentThread!}.\text{\lstinline!muMap!}[o_d]
\end{align*}
The second line demands that the locking state of any object must not have been changed. 
The last two lines ensure that the lock level of anything that is currently locked doesn't change.
When the user adds \lstinline[language=Chalice]!lockchange! declarations, the bodies of the last two quantifiers are guarded by an implication similar to:
\[
	o \notin \text{\lstinline!lockchange!} \Rightarrow \text{body\ldots}
\]
