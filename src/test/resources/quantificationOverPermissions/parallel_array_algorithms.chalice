class Cell { var value: int }

class ArrayOfInt { var array: seq<Cell> }

class ParMethods
{
  function contains(a: ArrayOfInt, start: int, end: int, item: int) : bool
    requires a != null && rd*(a.array) && 0 <= start && start <= end && end < |a.array|
	requires (forall i: int :: start <= i && i < end ==> rd((a.array[i]).value))
	ensures result == (exists i: int :: start <= i && i < end && a.array[i].value == item)
  {
    start != end && (a.array[start].value == item || contains(a, start+1, end, item))
  }

  method parallel_mergesort(a: ArrayOfInt, start: int, end: int)
    requires a != null && rd*(a.array) && (forall i, j: int :: 0 <= i && i<j && j < |a.array| ==> a.array[i] != a.array[j])
	requires 0 <= start && start <= end && end < |a.array|
	requires (forall i: int :: start <= i && i < end ==> acc((a.array[i]).value)) && (forall i, j: int :: start <= i && i<j && j < end ==> (a.array[i]).value != (a.array[j]).value)
	ensures (forall i: int :: start <= i && i < end ==> acc((a.array[i]).value))
	ensures (forall i, j: int :: start <= i && i<j && j < end ==> (a.array[i]).value < (a.array[j]).value)
	ensures (forall x: int :: contains(a, start, end, x) == old(contains(a, start, end, x)))
  {
    var middle: int
	if(end-start > 1)
	{
	  middle := start + (end-start)/2
	  fork tLeft := parallel_mergesort(a, start, middle)
	  fork tRight := parallel_mergesort(a, middle, end)
	  join tLeft
	  join tRight
	  call merge(a, start, middle, end)
	}
  }
  
  method merge(a: ArrayOfInt, start, middle, end)
    requires a != null && rd*(a.array) && (forall i, j: int :: 0 <= i && i<j && j < |a.array| ==> a.array[i] != a.array[j])
	requires 0 <= start && start < middle && middle < end && end < |a.array|
	requires (forall i: int :: start <= i && i < end ==> acc((a.array[i]).value))
	requires (forall i, j: int :: start <= i && i<j && j < middle ==> (a.array[i]).value < (a.array[i]).value)
	requires (forall i, j: int :: middle <= i && i<j && j < end ==> (a.array[i]).value < (a.array[i]).value)
	ensures (forall i, j: int :: start <= i && i<j && j < end ==> (a.array[i]).value < (a.array[i]).value)
	ensures (forall x: int :: contains(a, start, end, x) == old(contains(a, start, end, x)))
  {
    var I := start
	var J := middle
	var h: int
	var s1: Cell
	var s2: Cell
	
	while(I < middle && J < end)
	  invariant start<=I && I<=middle && middle<=J && J<=end
	  invariant rd*(a.array) && (forall i: int :: start<=i && i<end ==> acc((a.array[i]).value))
	  invariant (forall i, j: int :: start<=i && i<j && j<middle ==> (a.array[i]).value<(a.array[j]).value)
	  invariant (forall i, j: int :: middle<=i && i<j && j<J ==> (a.array[i]).value<(a.array[j]).value)
	  invariant (forall i, j: int :: J<=i && i<j && j<end ==> (a.array[i]).value<(a.array[j]).value)
	  invariant (forall i, j: int :: start<=i && i<I && middle<=j && j<J ==> (a.array[i]).value<(a.array[j]).value)
	  invariant (forall x: int :: contains(a, start, end, x) == old(contains(a, start, end, x)))
	{
	  if((a.array[I]).value < (a.array[J]).value) { I:=I+1 }
	  else
	  {
		s1 := a.array[J]
		s2 := a.array[I]
	    h := s1.value
		s2.value := s1.value
		s2.value := h
		J:=J+1
	  }
	}
  }
  
  method parallel_max(a: ArrayOfInt, start: int, end: int) returns(mx: int)
    requires a != null && rd*(a.array) && (forall i, j: int :: 0 <= i && i<j && j < |a.array| ==> a.array[i] != a.array[j])
	requires 0 <= start && start <= end && end < |a.array|
	requires (forall i: int :: start <= i && i < end ==> rd((a.array[i]).value))
	requires |a.array| >= 1
	ensures rd*(a.array) && (forall i: int :: start <= i && i < end ==> rd((a.array[i]).value))
	ensures contains(a, start, end, mx)
	ensures (forall i: int :: start<=i && i<end ==> (a.array[i]).value<=mx)
  {
    var middle: int
	var ml: int
	var mr: int
	
	if(end-start > 1)
	{
	  middle := start + (end-start)/2
	  fork tLeft := parallel_max(a, start, middle)
	  fork tRight := parallel_max(a, middle, end)
	  join ml := tLeft
	  join mr := tRight
	  mx := ml>mr ? ml : mr
	}
	else mx := (a.array[start]).value
  }
}