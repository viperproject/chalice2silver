channel ChTrue() where true

class Test {
	// method error1(ch: ChTrue)
		// requires ch != null && !credit(ch, -2) /* Type error */
	// {}

  method fails0(ch: ChTrue)
    requires ch != null && credit(ch, 2)
    requires rd(ch.mu) && waitlevel << ch.mu
  {
    receive ch
    receive ch
    receive ch /* @Error 2270 */
  }
  
  // method send_2(ch: ChTrue)
    // requires ch != null && credit(ch, -2) /* Lowers ch.mu below waitlevel */
    // requires rd(ch.mu) && waitlevel << ch.mu /* Contradicts */
  // { assert false }

  method fails1() {
    var ch: ChTrue := new ChTrue    
    assert credit(ch, 0)
    assert credit(ch, -2)
  }

  method branch(ch: ChTrue, n: int) returns (m: int)
    requires ch != null && rd(ch.mu) && waitlevel << ch.mu
    requires n != 0 && credit(ch, n)
    ensures credit(ch, m)
      /* Comment => Method body is not allowed to leave any debt. */
  {
    // if (credit(ch, 1)) /* Error: credit expression is allowed only in */
                          /*        positive predicate contexts */
    if (n > 0) {
      receive ch
      // C[ch] -= 1
      m := n - 1 /* Any int between n-1 and -infinity, otherwise: Method */
                 /* body is not allowed to leave any debt */
    } else {
      send ch()
      // C[ch] += 1 
      m := n + 1 /* Any int between n+1 and n-infinity, otherwise: Method */
                 /* body is not allowed to leave any debt */
    }
  }
	
	method in_expressions(ch: ChTrue, n: int)
		requires ch != null && rd(ch.mu) && waitlevel << ch.mu
		// requires credit(ch, 2) ==> n > 0 /* Only in positive predicate contexts */
		requires n > 0 ==> credit(ch, 2) /* OK */
		
	{
		// assert credit(ch, 2) == credit(ch, 2) /* Only in positive predicate contexts */
		// assert forall c: ChTrue :: credit(c, 2) /* Unexpected here */
		if (n > 0) {
			receive ch
			receive ch
		} else {
			send ch()
		}
	}
}