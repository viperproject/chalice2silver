/* The following code illustrates an incompleteness resulting from the function
 * application caching mechanism as it existed in r8017.
 * The problem arises from the fact that assertions, e.g. postconditions, are 
 * produced in an empty heaps (in order to ensure self-framing), thereby
 * generating fresh snapshots all the time which are often identified as aliases
 * of already existing snapshots once the newly produced heap is joined with
 * the already existing heap.
 * Caching can unfortunately prevent this identification, thus resulting in
 * incompletenesses.
 *
 * 2011-09-07 MHS:
 * 		Consequently, the example verifies if --disableSelfFramingProductions
 *    is used.
 */

class Cell {
	var x: int
	predicate P { acc(x) }
	predicate PP { rd(P) }
	
	method foldP(y: int)
		requires acc(x)
		ensures P && get() == y
	{
		x := y
		fold P
	}
	
	function get(): int
		requires rd(P)
	{ unfolding rd(P)	in x }
	
	method foldPP()
		requires acc(P, rd(P))
		ensures PP && getget() == unfolding PP in get()
	{ fold PP }
	
	function getget(): int
		requires rd(PP)
	{ unfolding rd(PP) in get() }
}

class Test2 {
	method test() {
		var c: Cell := new Cell

		call c.foldP(1)
			// h: {c.P[ts]#rd}
			// π: {c.get[ts]() == 1,  c.get[ts]() == ts}
			// The second equality results from evaluating 'get() == y'.
			// The first equality results from relating the function application
			// c.get() (framed by P) to the evaluation of its body, which is done
			// during the evaluation of 'get() == y'.
		
		call c.foldPP()
			// The problem with caching function applications is that the following
			// postcondition of c.foldPP()
			//   PP && getget() == unfolding PP in getget() == _'
			// is produced in an empty heap. Notice that in order for the the bug to 
			// manifest itself it is not relevant in which context getget() is
			// invoked, only that it is invoked.
			// 1. produce 'PP' --> h1 := Ø + {c.PP[ts1]}
			// 2. produce 'unfolding PP in getget()'
			//      - getget() is rendered the function application term (FApp)
			//        'c.getget[ts1]()'
			//      - getget()'s body is evaluated:
			//          - that is, 'unfolding rd(PP) in get()' will be evaluated in
			//            h1, creating a temporary heap h2 := h1 + {c.P[ts1]#rd}
			//          - thus, evaluating 'get()' in h2 will yield the path condition
			//            'c.get[ts1]() == ts1', as the result of relating the
			//            function application to the evaluation of its body.
			//      - The result of the evaluation of getget()'s body is the term
			//        'c.get[ts1]()'
			//    BUT, since the production took place in the empty heap - more
			//    precisely, in a heap in which 'c.P[ts]#rd' is not present,
			//    the snapshots 'ts' and 'ts1' are not related. That is, they are
			//    not known to be equal.
			//
			// If caching is activated then the FApp term 'c.getget[ts1]()' is used
			// as the cache key, pointing to the body term 'c.get[ts1]()'. Moreover,
			// all additional path conditions, e.g. 'c.get[ts1]() == ts1', are also
			// stored under that key. However, the crucial path condition 'ts == ts1'
			// is missing since it hasn't been produced.
			//
			// h: {c.PP[ts1]}
			// π: {c.get[ts]() == 1,  c.get[ts]() == ts,  c.get[ts1]() == ts1}
		
		assert c.getget() == 1 /* Used to fail */
			// 'getget()' is evaluated into the FApp term 'c.getget[ts1]()'.
			//
			// If caching is activated then there already exists an entry for that
			// FApp term, and the function body will NOT be evaluated again.
			// The assertion will now fails since it is not known that
			// 'c.getget[ts1]() == 1'.
			//
			// If caching was deactivated then getget()'s body would be evaluated,
			// this time in a heap where 'c.P[ts]#rd' is present. During the
			// evaluation the additional chunk ''c.P[ts1]#rd' would be added, from
			// which Syxc concludes that 'ts == ts1' which - together with the other
			// path conditions - finally makes the assertion 'c.getget[ts1]() == 1'
			// hold.
	}
}

/* The above code is the gist of the following linked list code. In contrast
 * to the former the linked list example is of real interest.
 */

class List {
  var next:List;
  
  predicate inv { acc(next) && (next != null ==> rd(next.inv)) }
	
	method init(n: List)
		requires acc(next) && (n != null ==> acc(n.inv, rd(n.inv)))
		ensures inv
		ensures 0 < len()
		ensures unfolding inv in next == n
		ensures len() == 1 + unfolding inv in (next == null ? 0 : next.len())
	{
		next := n
		fold inv
		assume 0 < len() /* Would usually be a call to lemma_length_positive() */
	}
	
  unlimited function len():int
    requires rd(inv);
  { unfolding rd(inv) in (next==null) ? 1 : (1 + next.len()) }
}


class TestList {
	method test() {
		var n1: List := new List
		call n1.init(null)
		
		var n2: List := new List
		call n2.init(n1)
		// assert unfolding n2.inv in true
		assert n2.len() == 2 /* Used to fail */
	}
}