class Test {	
	var b1: bool
	var b2: bool
	var b3: bool
	
	invariant acc(b1)
	invariant (b1 ==> true)
	invariant acc(b2)
	invariant (b2 ==> true)
	// invariant acc(b3)
	// invariant b3 ==> true
	
	predicate PP { /* Pure implications */
			 acc(b1) && (b1 ==> true)
		&& acc(b2) && (b2 ==> true)
		// && acc(b3) && (b3 ==> true)
	}
	
	var x1: int
	var x2: int
	var x3: int
	
	predicate IP { /* Impure implications */
			 acc(b1) && (b1 ==> acc(x1))
		&& acc(b2) && (b2 ==> acc(x2))
		// && acc(b3) && (b3 ==> acc(x3))
	}
	
	method havoc_PP() requires PP ensures PP {}
	method havoc_IP() requires IP ensures IP {}
	
  method unfolds_PP()
		requires acc(PP)
  {
		/* (2^a)^1 branches, where a is the number of implications in PP.
		 * The number of branches does not increase with the number of unfold-fold
		 * statements because when the first unfold branches it fixed the values
		 * of the antecedents, which prevents subsequent unfold-folds from
		 * branching (one branch is always inconsistent).
		 */

		unfold PP; fold PP // (2^a)^1
		unfold PP; fold PP // (2^a)^1
		unfold PP; fold PP // (2^a)^1
		unfold PP; fold PP // (2^a)^1
		unfold PP; fold PP // (2^a)^1
  }
	
  method unfolds_havoc_PP()
		requires acc(PP)
  {
		/* (2^a)^i branches, where a is the number of implications in PP and i is
		 * the number of subsequent unfold-fold pairs.
		 * However, the new implementation avoids branching all together if the
		 * branching expression is pure.
		 * More precisely, evaluating a pure implication does not symbolically
		 * execute the complete program in both branches, but rather evaluates
		 * a pure implication into an implication term, which is just another
		 * path condition that is assumed during the rest of the execution.
		 */
		unfold PP; fold PP; call havoc_PP() // (2^a)^1
		unfold PP; fold PP; call havoc_PP() // (2^a)^2
		unfold PP; fold PP; call havoc_PP() // (2^a)^3
		unfold PP; fold PP; call havoc_PP() // (2^a)^4
		unfold PP; fold PP; call havoc_PP() // (2^a)^5
  }
	
  method unfolds_IP()
		requires acc(IP)
  {
		/* (2^a)^1 branches */
		unfold IP; fold IP
		unfold IP; fold IP
		unfold IP; fold IP
		unfold IP; fold IP
		unfold IP; fold IP
  }
	
  method unfolds_havoc_IP()
		requires acc(IP)
  {
		/* (2^a)^i branches */
		unfold IP; fold IP; call havoc_IP()
		unfold IP; fold IP; call havoc_IP()
		unfold IP; fold IP; call havoc_IP()
		unfold IP; fold IP; call havoc_IP()
		unfold IP; fold IP; call havoc_IP()
  }
	
  method acquire_release()
		requires acc(this.mu) && waitlevel << this
  {
		/* Is equivalent to unfolds_havoc in terms of branching behaviour. */
		acquire this; release this
		acquire this; release this 
		acquire this; release this
		acquire this; release this
		acquire this; release this
  }
}