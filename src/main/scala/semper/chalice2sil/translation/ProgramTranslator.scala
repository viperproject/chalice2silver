package semper.chalice2sil.translation

import semper.sil.ast._
import scala.collection._
import mutable.Map
import semper.chalice2sil.messages._
import scala.Some

/**
 * Author: Yannis Kassios (based on an older version by Christian Klauser)
 */

// todo: later add the following functionality: deadlock avoidance, set/seq support, fix epsilon permissions,
  // error-message and obsolete classes refactoring, aggregates support, channels support

class ProgramTranslator(val programOptions: semper.chalice2sil.ProgramOptions, val programName: String)
{
  // messages generated in the translation
    // todo: refactor error messages
  val messages = scala.collection.mutable.ListBuffer[semper.chalice2sil.Message]()

  // maps Chalice member names (fields, methods, functions, predicates) to the corresponding SIL entities
    // the string "FullName" of each Chalice member followed by a $ sign is used as key
  val silEnvironment = new SILProgramEnvironment()

  // maps tokens to the corresponding forked Chalice method
    // at most one method fork per token is allowed within a method
    // todo: refactor joining, using information from the "joinable" Chalice class
  val joinTokens = new scala.collection.mutable.HashMap[(Method, String), JoinableInfo]()

  // maps monitor invariants from Chalice to SIL predicates
  val silTranslatedInvariants = new scala.collection.mutable.HashMap[chalice.Class, Predicate]()

  // maps Chalice members (fields, methods, function, predicates) to corresponding SIL members
  val symbolMap = new scala.collection.mutable.HashMap[chalice.ASTNode, Node]()

  // name generator -- ensures uniqueness and validity of names of identifiers
    // CONVENTION: all local variables maintain their names from Chalice.  To prevent clashes, all names generated by
    // nameGenerator must include the symbol $
    // todo: explore if this convention works in the presence of nested code blocks, otherwise use symbolMap
  val nameGenerator = new semper.sil.utility.SilNameGenerator

  // this domain introduces the constant K permission for use in monitor invariants
    // todo: axiom: the K permission is read-only
  val globalK = DomainFunc(nameGenerator.createIdentifier("globalK$"), Seq(), Perm, true)()
  val GlobalKPermissionDomain = Domain("GlobalKPermission", Seq(globalK), Seq(), Seq())()

  // **
  // takes a Chalice program as a sequence of Chalice top level declarations
  // produces a SIL program and a sequence of error/warnings
  // **
  def translate(decls : Seq[chalice.TopLevelDecl]) : (Program, Seq[semper.chalice2sil.Message]) = {
    // collect all top level symbols and populates silEnvironment and silInvariants
    decls.foreach(collectSymbols)

    // translate each class
    decls.foreach(translate)

    // return the final SIL program together with the list of error/warnings produced
    (Program(List(GlobalKPermissionDomain), silEnvironment.silFields.values.toSeq,
      silEnvironment.silFunctions.values.toSeq, silEnvironment.silPredicates.values.toSeq,
      silEnvironment.silMethods.values.toSeq)(),
     messages.toSeq)
  }

  // **
  // collects all symbols associated with a class and populates silEnvironment and silInvariants
  // **
  protected def collectSymbols(decl : chalice.TopLevelDecl) {
    decl match {
      case c:chalice.Class if c.IsNormalClass => collectSymbols(c)

      // only classes are supported as top-level declarations in the present version
      case node => messages += UnknownAstNode(node)
    }
  }

  // **
  // collects all symbols associated with a class and populates silEnvironment and silInvariants
  // **
  protected def collectSymbols(classNode : chalice.Class){
    classNode.members.view foreach {
      // field
      case f:chalice.Field =>
        val newField = Field(nameGenerator.createIdentifier(f.FullName+"$"), translateType(f.typ))(
          SourcePosition(null, f.pos.line, f.pos.column)
        )
        symbolMap(f) = newField
        silEnvironment.silFields += (newField.name -> newField)

      // predicate
      case p:chalice.Predicate =>
        val ths = nameGenerator.createIdentifier("this$")
        val newPredicate =
          Predicate(nameGenerator.createIdentifier(p.FullName+"$"), LocalVarDecl(ths, Ref)(), null)(
            SourcePosition(null, p.pos.line, p.pos.column)
          )
          // a predicate has a single reference parameter that refers to the receiver
          // the body is to be filled later
        symbolMap(p) = newPredicate
        silEnvironment.silPredicates += (newPredicate.name -> newPredicate)

      // method
      case m:chalice.Method =>
        val ths = nameGenerator.createIdentifier("this$")
        val k = nameGenerator.createIdentifier("k$")
        val myThis = LocalVarDecl(ths, Ref)()
        val myK = LocalVarDecl(k, Perm)()
        val ins = myThis :: myK :: translateVars(m.ins)
        val newMethod = Method(nameGenerator.createIdentifier(m.FullName+"$"), ins, translateVars(m.outs),
          null, null, null, null)(SourcePosition(null, m.pos.line, m.pos.column))
          // a method in SIL has a reference parameter that refers to the receiver and a permission parameter that
          // refers to all unspecified read permissions in its precondition
          // the body and the specs are to be filled in later
        symbolMap(m) = newMethod
        silEnvironment.silMethods += (newMethod.name -> newMethod)

      // function
      case f:chalice.Function =>
        val ths = nameGenerator.createIdentifier("this$")
        val myThis = LocalVarDecl(ths, Ref)()
        val ins = myThis :: translateVars(f.ins)
        val newFunction = Function(nameGenerator.createIdentifier(f.FullName+"$"), ins, translateType(f.out),
          null, null, null)(SourcePosition(null, f.pos.line, f.pos.column))
          // a function has a reference parameter that refers to the receiver
          // the body and the precondition are to be filled later
        symbolMap(f) = newFunction
        silEnvironment.silFunctions += (newFunction.name -> newFunction)

      // other members (e.g., monitor invariants) are ignored for now
      case _ =>
    }
  }

  // **
  // translates all members of a class and populates missing bodies and specifications in the corresponding SIL members
  // **
  protected def translate(decl : chalice.TopLevelDecl) {
    decl match {
      case c:chalice.Class if c.IsNormalClass => translate(c)

      // only classes are supported as top-level declarations in the present version
      case node => messages += UnknownAstNode(node)
    }
  }

  // **
  // translates all members of a class and populates missing bodies and specifications in the corresponding SIL members
  // also deals with the monitor invariant of a class
  // **
  protected def translate(classNode: chalice.Class) = {
    // a "this" declaration for the invariants
    val ths = LocalVarDecl(nameGenerator.createIdentifier("this$"), Ref)()

    // an expression to store the monitor invariant
    var monitorInvariant : Exp = TrueLit()()

    // translate one member at a time
    classNode.members.foreach({
      case m: chalice.Method  => translateMethod(m)
      case p: chalice.Predicate => translatePredicate(p)
      case f: chalice.Function => translateFunction(f)
      case i: chalice.MonitorInvariant =>
        // translate the found invariant expression and conjoin it to the already translated invariants
          // all invariants refer to the same receiver object and their read permission is given by globalK
        val currentInv = translateExp(i.e, ths, PredicatePermissionTranslator(globalK))
        monitorInvariant = And(currentInv, monitorInvariant)()

      // no other nodes are supported
      case otherNode => messages += UnknownAstNode(otherNode)
    })

    // translate monitorInvariant into a SIL predicate
    val pName = nameGenerator.createIdentifier(classNode.FullName + "$MonitorInvariant")
    val monitorPredicate = Predicate(pName, ths, monitorInvariant)()
    silEnvironment.silPredicates += (pName -> monitorPredicate)
    silTranslatedInvariants(classNode) = monitorPredicate
  }

  // **
  // translates a Chalice class into a SIL type
  // **
  protected def translateType(cType: chalice.Class) : Type = translateType(Util.convertToType(cType))

  // **
  // translates a Chalice type into a SIL type
  // **
    // todo: refactor: move the translateType methods into Util object
  protected def translateType(cType: chalice.Type) : Type = {
    cType.id match {
      case "seq" =>
        // YANNIS: todo
 /*       if(typ.params.length != 1) { messages += WrongNumberOfTypeParameters; Int }
        val tvm = Map[TypeVar, Type]()
        val silT = translateType(cType.params.head)
        tvm += (typeVar, silT)
        new DomainType(seqDomain, tvm)*/
        null
      case "set" =>
        // YANNIS: todo
/*        if(typ.params.length != 1) { messages += WrongNumberOfTypeParameters; Int }
        else {
          val silT = translateType(cType.params.head)
          val tvm = Map(SetDomain.typeVar -> silT)
          tvm += (typeVar, silT)
          new DomainType(SetDomain, tvm)
        }*/
        null
      case "int" => Int
      case "bool" => Bool
      case "$Permission" => Perm
      case _ => Ref
        // todo: add other Chalice-internal classes
    }
  }

  // **
  // translates a list of Chalice arguments into the corresponding SIL arguments
  // new local variables with the same name are created
  // **
  protected def translateVars(cVars: Seq[chalice.Variable]) = {
    val result = scala.collection.mutable.ListBuffer[LocalVarDecl]()
    cVars.foreach((x: chalice.Variable) =>
      result += LocalVarDecl(x.id, translateType(x.t))(SourcePosition(null, x.pos.line, x.pos.column))
    )
    result.toList
  }

  // **
  // translate a Chalice predicate into a SIL predicate
  // **
  protected def translatePredicate(cPredicate: chalice.Predicate) = {
    // obtain the corresponding SIL predicate
      // todo: bugfix: use symbolmap here!
    val sPredicate = silEnvironment.silPredicates(cPredicate.FullName + "$")

    // obtain the single argument of the predicate as the receiver object
    val sThis = sPredicate.formalArg

    // populate the predicate body translating the corresponding Chalice body and using the given receiver and the
    // global unidentified read permission for predicates
    sPredicate.body = translateExp(cPredicate.definition, sThis, PredicatePermissionTranslator(globalK))
  }

  // **
  // translate a Chalice function into a SIL function
  // **
  protected def translateFunction(cFunction: chalice.Function) = {
    // obtain the corresponding SIL function
      // todo: bugfix: use symbolmap here!
    val sFunction = silEnvironment.silFunctions(cFunction.FullName + "$")

    // obtain the receiver, which is the first in the list of formal arguments of the SIL function
    val sThis = sFunction.formalArgs(0)

    // precondition this!=null
    val thisNotNull = NeCmp(sThis.localVar, NullLit()())()

    // translate specifications
      // all permissions in the preconditions are rendered to a read permission
    val silPreconditions = scala.collection.mutable.ListBuffer[Exp](thisNotNull)
    val silPostConditions = scala.collection.mutable.ListBuffer[Exp]()
    cFunction.spec.foreach {
      _ match {
        case chalice.Precondition(e) => silPreconditions +=
          translateExp(e, sThis, FunctionPermissionTranslator())
        case chalice.Postcondition(e) => silPostConditions +=
          translateExp(e, sThis, FunctionPermissionTranslator())
      }
    }
    sFunction.pres = silPreconditions.toSeq
    sFunction.posts = silPostConditions.toSeq

    // translate body into SIL and populate the body of the SIL function appropriately
      // all permissions in the body are rendered to a read permission
    cFunction.definition match {
      case Some(body) => sFunction.exp = translateExp(body, sThis, FunctionPermissionTranslator())
    }
  }

  // **
  // translate a Chalice method into a SIL method
  // **
  protected def translateMethod(cMethod: chalice.Method) = {
    // obtain the corresponding SIL method
      // todo: bugfix: use symbolmap here!
    val sMethod = silEnvironment.silMethods(cMethod.FullName + "$")

    // obtain receiver, unidentified read permission argument and create a method permission translator
    val sThis = sMethod.formalArgs(0)
    val sK = sMethod.formalArgs(1)
    val permTranslator = MethodPermissionTranslator(sK)

    // precondition this!=null && K>0
    val thisNotNull = NeCmp(sThis.localVar, NullLit()())()
    val kRead = PermGtCmp(sK.localVar, NoPerm()())()

    // translate specifications
    val silPreconditions = scala.collection.mutable.LinkedList[Exp](thisNotNull, kRead)
    val silPostConditions = scala.collection.mutable.LinkedList[Exp]()
    cMethod.spec.foreach {
      _ match {
        case chalice.Precondition(e) =>
          silPreconditions.append(scala.collection.mutable.LinkedList(translateExp(e, sThis, permTranslator)))
        case chalice.Postcondition(e) =>
          silPostConditions.append(scala.collection.mutable.LinkedList(translateExp(e, sThis, permTranslator)))
      }
    }
    sMethod.pres = silPreconditions.toSeq
    sMethod.posts = silPostConditions.toSeq

    // translate body into SIL and populate the body of the SIL method appropriately
    translateBody(cMethod, sThis, permTranslator)
  }

  protected def translateExp(cExp: chalice.Expression, myThis: LocalVarDecl, pTrans: PermissionTranslator) : Exp = {
    val position = SourcePosition(null, cExp.pos.line, cExp.pos.column)
    cExp match {
      // old expression
      case chalice.Old(inner) => Old(translateExp(inner, myThis, pTrans))(position)

      // chalice2sil ignores all deadlock prevention specs;
      case chalice.LockBelow(_,_) =>  TrueLit()(position)
      case chalice.Eq(chalice.MaxLockLiteral(),_) => TrueLit()(position)
      case chalice.Eq(_,chalice.MaxLockLiteral()) => TrueLit()(position)

      // logical operators
      case chalice.And(lhs, rhs) =>
        And(translateExp(lhs, myThis, pTrans), translateExp(rhs, myThis, pTrans))(position)
      case chalice.Or(lhs, rhs) =>
        Or(translateExp(lhs, myThis, pTrans), translateExp(rhs, myThis, pTrans))(position)
      case chalice.Implies(lhs, rhs) =>
        Implies(translateExp(lhs, myThis, pTrans), translateExp(rhs, myThis, pTrans))(position)
      case chalice.Eq(lhs, rhs) =>
        EqCmp(translateExp(lhs, myThis, pTrans), translateExp(rhs, myThis, pTrans))(position)
      case chalice.Neq(lhs, rhs) =>
        NeCmp(translateExp(lhs, myThis, pTrans), translateExp(rhs, myThis, pTrans))(position)
      case chalice.Not(op) => Not(translateExp(op, myThis, pTrans))(position)
      case chalice.IfThenElse(cond, thn, els) =>
        CondExp(
          translateExp(cond, myThis, pTrans), translateExp(thn, myThis, pTrans), translateExp(els, myThis, pTrans)
        )(position)

      // arithmetic operators and set union, subtraction, intersection
      case chalice.Plus(lhs, rhs) =>
        val l = translateExp(lhs, myThis, pTrans)
        val r = translateExp(rhs, myThis, pTrans)
        if(lhs.typ == chalice.IntClass) Add(l, r)(position)
        else { // if lhs is not int, this translates to set union
/*          var t = l.typVarsMap.getOrElse(SetDomain.typeVar, null)
          if(t == null) { messages += TypeError(l) ; t = Int }
          new DomainFuncApp(SetDomain.union, List(l, r), t)*/ null // sets are not supported
        }
      case chalice.Minus(lhs, rhs) =>
        val l = translateExp(lhs, myThis, pTrans)
        val r = translateExp(rhs, myThis, pTrans)
        if(lhs.typ == chalice.IntClass) Sub(l, r)(position)
        else { // if lhs is not int, this translates to set subtraction
          /*var t = l.typVarsMap.getOrElse(SetDomain.typeVar, null)
          if(t == null) { messages += TypeError(l) ; t = Int }
          new DomainFuncApp(SetDomain.subtraction, List(l, r), t)*/  null // sets are not supported
        }
      case chalice.Times(lhs, rhs) =>
        val l = translateExp(lhs, myThis, pTrans)
        val r = translateExp(rhs, myThis, pTrans)
        if(lhs.typ == chalice.IntClass) Mul(l, r)(position)
        else { // if lhs is not int, this translates to set intersection
          /*var t = l.typVarsMap.getOrElse(SetDomain.typeVar, null)
          if(t == null) { messages += TypeError(l) ; t = Int }
          new DomainFuncApp(SetDomain.intersection, List(l, r), t)*/ null // sets are not supported
        }
      case chalice.Div(lhs, rhs) =>
        Div(translateExp(lhs, myThis, pTrans), translateExp(rhs, myThis, pTrans))(position)
      case chalice.Mod(lhs, rhs) =>
        Mod(translateExp(lhs, myThis, pTrans), translateExp(rhs, myThis, pTrans))(position)

      // equality and inequality
      case chalice.Eq(lhs, rhs) =>
        EqCmp(translateExp(lhs, myThis, pTrans), translateExp(rhs, myThis, pTrans))(position)
      case chalice.Neq(lhs, rhs) =>
        NeCmp(translateExp(lhs, myThis, pTrans), translateExp(rhs, myThis, pTrans))(position)

      // arithmetic and set comparison operators
      case chalice.Less(lhs, rhs) =>
        val l = translateExp(lhs, myThis, pTrans)
        val r = translateExp(rhs, myThis, pTrans)
        if(lhs.typ == chalice.IntClass) LtCmp(l, r)(position)
        else { // if lhs is not int, this translates to set proper inclusion
          /*var t = l.typVarsMap.getOrElse(SetDomain.typeVar, null)
          if(t == null) { messages += TypeError(l) ; t = Int }
          new DomainFuncApp(SetDomain.subset, List(l, r), t)*/ null // sets are not supported
        }
      case chalice.AtMost(lhs, rhs) =>
        val l = translateExp(lhs, myThis, pTrans)
        val r = translateExp(rhs, myThis, pTrans)
        if(lhs.typ == chalice.IntClass) LeCmp(l, r)(position)
        else { // if lhs is not int, this translates to set proper inclusion
          /*var t = l.typVarsMap.getOrElse(SetDomain.typeVar, null)
          if(t == null) { messages += TypeError(l) ; t = Int }
          new DomainFuncApp(SetDomain.subsetEq, List(l, r), t)*/  null // sets are not supported
        }
      case chalice.AtLeast(lhs, rhs) =>
        val l = translateExp(lhs, myThis, pTrans)
        val r = translateExp(rhs, myThis, pTrans)
        if(lhs.typ == chalice.IntClass) GeCmp(l, r)(position)
        else { // if lhs is not int, this translates to set proper inclusion
          /*var t = l.typVarsMap.getOrElse(SetDomain.typeVar, null)
          if(t == null) { messages += TypeError(l) ; t = Int }
          new DomainFuncApp(SetDomain.supsetEq, List(l, r), t)*/  null // sets are not supported
        }
      case chalice.Greater(lhs, rhs) =>
        val l = translateExp(lhs, myThis, pTrans)
        val r = translateExp(rhs, myThis, pTrans)
        if(lhs.typ == chalice.IntClass) GtCmp(l, r)(position)
        else { // if lhs is not int, this translates to set proper inclusion
          /*var t = l.typVarsMap.getOrElse(SetDomain.typeVar, null)
          if(t == null) { messages += TypeError(l) ; t = Int }
          new DomainFuncApp(SetDomain.supset, List(l, r), t)*/  null // sets are not supported
        }

      // sequence operators
      case chalice.EmptySeq(t) => EmptySeq(translateType(t))(position)
      case chalice.ExplicitSeq(elems) => ExplicitSeq(elems.map(translateExp(_, myThis, pTrans)))(position)
      case chalice.Range(lhs, rhs) =>
        new RangeSeq(translateExp(lhs, myThis, pTrans), translateExp(rhs, myThis, pTrans))(position)
      case chalice.Length(e) => SeqLength(translateExp(e, myThis, pTrans))(position)
      case chalice.At(lhs, rhs) =>
        SeqIndex(translateExp(lhs, myThis, pTrans), translateExp(rhs, myThis, pTrans))(position)
      case chalice.Drop(lhs, rhs) =>
        SeqDrop(translateExp(lhs, myThis, pTrans), translateExp(rhs, myThis, pTrans))(position)
      case chalice.Take(lhs, rhs) =>
        SeqTake(translateExp(lhs, myThis, pTrans), translateExp(rhs, myThis, pTrans))(position)
      case chalice.Contains(lhs, rhs) =>
        SeqContains(translateExp(lhs, myThis, pTrans), translateExp(rhs, myThis, pTrans))(position)

      // remaining set operators: not supported

      // member access
      case _:chalice.ThisExpr => myThis.localVar
      case ma@chalice.MemberAccess(e, id) =>
        val cls = e.typ
        if(cls!=null)
        {
          cls.LookupMember(id) match {
            case None => messages += TypeError() ; null
            case Some(f) =>
              val sf = symbolMap.getOrElse(f, null)
              if (sf == null) { messages += TypeError() ; null }
              else {
                if(f.isInstanceOf[chalice.Field])
                  FieldAccess(translateExp(e, myThis, pTrans), sf.asInstanceOf[Field])(position)
                else PredicateAccess(translateExp(e, myThis, pTrans), sf.asInstanceOf[Predicate])(position)
              }
          }
        }
        else { messages += TypeError() ; null }
        // YANNIS: todo: case class BackPointerMemberAccess(ex: Expression, typeId: String, fieldId: String) extends Expression {}

      // access permissions
      case chalice.Access(ma, perm) =>
        val silma = translateExp(ma, myThis, pTrans)
        val silpe = pTrans(perm, myThis)
        if (ma.isPredicate) PredicateAccessPredicate(silma.asInstanceOf[PredicateAccess], silpe)(position)
        else FieldAccessPredicate(silma.asInstanceOf[FieldAccess], silpe)(position)
      case chalice.BackPointerAccess(ma, perm) =>
        val silma = translateExp(ma, myThis, pTrans)
        val silpe = pTrans(perm, myThis)
        FieldAccessPredicate(silma.asInstanceOf[FieldAccess], silpe)(position)

      case chalice.AccessAll(obj, perm) =>
        val silo = translateExp(obj, myThis, pTrans)
        val silpe = pTrans(perm, myThis)
        var silexp : Exp = TrueLit()()

        if(obj==null || obj.typ == null) messages += UnknownAstNode(obj)
        else {
            // add access to all declared fields and predicates
          obj.typ.DeclaredFields.foreach{ f =>
            val sf = symbolMap.getOrElse(f, null)
            if (sf == null) messages += TypeError()
            else silexp = And(silexp, FieldAccessPredicate(FieldAccess(silo, sf.asInstanceOf[Field])(), silpe)())()
          }

           // YANNIS: todo: does this cover predicates or only fields?

           // YANNIS: todo: add access to backpointer fields

         }

         // return the complete access permission expression
         silexp

      case chalice.AccessSeq(seq, member, perm) => // YANNIS: todo: refactor this case
          val silseq = translateExp(seq, myThis, pTrans)
          val silpe = pTrans(perm, myThis)
          var permissionPerObject : Exp => Unit = null
          var silexp: Exp = TrueLit()()
            // this closure will return the permission expression for each element of the sequence

          // define permissionPerObject
          member match {
            case None =>
              if(seq==null || seq.typ==null) messages += UnknownAstNode(seq) // YANNIS: todo: other health conditions
              else {
                  permissionPerObject = (exp => {
                    seq.typ.parameters(0).DeclaredFields.foreach{ f =>
                        val sf = symbolMap.getOrElse(f, null)
                        if (sf == null) messages += TypeError()
                        else
                          silexp = And(silexp, FieldAccessPredicate(FieldAccess(exp, sf.asInstanceOf[Field])(), silpe)())() }
                    // YANNIS: todo: fix.  the above code includes Chalice predicates, which should be coded as
                       // PredicateAccessPredicate objects
                    // YANNIS: todo: add access to backpointer fields
                  })
               }
            case Some(f) =>
              if(f.isPredicate) permissionPerObject =
                (exp => { silexp = PredicateAccessPredicate(exp.asInstanceOf[PredicateAccess], silpe)(position)})
              else permissionPerObject =
                (exp => silexp = FieldAccessPredicate(silseq.asInstanceOf[FieldAccess], silpe)(position))
           }

                    // YANNIS: todo: check: is this enough for backpointer access here?

         // return a universal quantification on all sequence elements
         val boundedId = nameGenerator.createIdentifier("i")
         permissionPerObject(SeqIndex(silseq, LocalVar(boundedId)(Int))())
          // YANNIS: todo: ensure that (in exceptional conditions) the flow does not reach this point
          // YANNIS: todo: bound the index of the array in the quantification
         Forall(List(LocalVarDecl(boundedId, Int)()), List(), silexp)(position)
     /*
           // YANNIS: todo: this case
      case expression@chalice.Access(chalice.MemberAccess(tokenExpr, joinableName), permission)
        if tokenExpr.typ.IsToken && joinableName == prelude.Token.joinable.name => {
        // translate `acc(token.joinable,X)` to `(acc(token.joinable,X) && acc(token.args/olds,X)...)`
        // i.e., make sure that arg/old fields always have the same permissions as token.joinable.
        val m = methods(tokenExpr.typ.asInstanceOf[chalice.TokenClass].method)
        val tokenExpression = translateExpression(tokenExpr)
        translateAccessExpression(permission) {
          permAmount =>
            m.callToken.allFields
              .map(currentExpressionFactory.makeFieldPermissionExpression(tokenExpression, _, permAmount, expression))
              .reduce[Expression](currentExpressionFactory.makeBinaryExpression(And()(expression), _, _, expression))
        }
      }  */

      // unfolding
      case unfolding@chalice.Unfolding(predicateAccess, body) =>
        val silpa = translateExp(predicateAccess, myThis, pTrans)
        val silbody = translateExp(body, myThis, pTrans)
        Unfolding(silpa.asInstanceOf[PredicateAccessPredicate], silbody)(position)

      // eval is not supported
      case e: chalice.Eval => messages += GeneralEvalNotImplemented(e) ; null

       // quantification and aggregation
        // YANNIS: todo: bounded identifiers must be constructed with the name generator too
      case e: chalice.Quantification =>
        var boundedVars : List[LocalVarDecl] = null
        var boundingExpression: Exp = null
        if (e.isInstanceOf[chalice.TypeQuantification])
          boundedVars = e.Is map { i => LocalVarDecl(i, translateType(e.asInstanceOf[chalice.TypeQuantification].t))() }
        else if (e.isInstanceOf[chalice.SeqQuantification]) {
          val seq = e.asInstanceOf[chalice.SeqQuantification].seq
          val silseq = translateExp(seq, myThis, pTrans)
          val tp = translateType(new chalice.Type(seq.typ.asInstanceOf[chalice.SeqClass].parameter))
          boundedVars = e.Is map { i =>
            boundingExpression = And(boundingExpression, SeqContains(LocalVar(i)(tp), silseq)())()
            LocalVarDecl(i, tp)()
          }
        }
        else {
          val set =  e.asInstanceOf[chalice.SetQuantification].dom
          val tp = translateType(new chalice.Type(set.typ.asInstanceOf[chalice.SetClass].parameter))
          val silset = translateExp(set, myThis, pTrans)
          boundedVars = e.Is map { i =>
            boundingExpression = And(boundingExpression, SeqContains /*YANNIS: todo: SetContains*/ (LocalVar(i)(tp), silset)())()
            LocalVarDecl(i, tp)()
          }
        }
        val silbody = translateExp(e.E, myThis, pTrans)  // e.E refers to the body of the quantification
        e.Q match {
          case chalice.Forall => Forall(boundedVars, Seq(), Implies(boundingExpression, silbody)())(position)
          case chalice.Exists =>  Exists(boundedVars, And(boundingExpression, silbody)())(position)
          case _ => messages += UnknownAstNode(e) ; null
        }

      case chalice.BoolLiteral(b) => if(b) TrueLit()(position) else FalseLit()(position)
      case chalice.IntLiteral(n) => IntLit(n)(position)
      case chalice.NullLiteral() => NullLit()(position)
      case chalice.StringLiteral(s) => null // YANNIS: todo: SIL does not support strings
      case chalice.LockBottomLiteral() => null
      case chalice.MaxLockLiteral() => null
      case chalice.ImplicitThisExpr() => myThis.localVar
      case chalice.ExplicitThisExpr() => myThis.localVar
      case chalice.VariableExpr(v) => LocalVar(v)(translateType(cExp.typ))
     }
  }

  protected def translateBody(cMethod: chalice.Method, myThis: LocalVarDecl, pTrans: PermissionTranslator) = {
    val sMethod = symbolMap(cMethod).asInstanceOf[Method]
    sMethod.locals = Seq()
    sMethod.body = Seqn(cMethod.body.map(translateStm(_, myThis, pTrans, sMethod)))()
  }

  protected def translateStm(cStm: chalice.Statement, myThis: LocalVarDecl,
                             pTrans: PermissionTranslator, silMethod: Method) : Stmt = {
    val position = new SourcePosition(null, cStm.pos.line, cStm.pos.column)
    cStm match {
      case chalice.Assert(e) => Assert(translateExp(e, myThis, pTrans))(position)
      case chalice.Assume(e) => Inhale(translateExp(e, myThis, pTrans))(position)
      case chalice.BlockStmt(ss) => Seqn(ss.map(translateStm(_, myThis, pTrans, silMethod)))(position)
      case chalice.IfStmt(guard, chalice.BlockStmt(thn), els) =>
        If(translateExp(guard, myThis, pTrans), Seqn(thn.map(translateStm(_, myThis, pTrans, silMethod)))(),
          els match {
            case None => Seqn(Seq())()
            case Some(s) => translateStm(s, myThis, pTrans, silMethod)
          }
        )(position)
      case w@chalice.WhileStmt(guard, _, _, _ /*YANNIS: todo: lockchange not supported*/, body) =>
        // YANNIS: todo: what is the difference between newInvs and oldInvs?
        While(translateExp(guard, myThis, pTrans), w.Invs.map(translateExp(_, myThis, pTrans)), Seq(),
          translateStm(body, myThis, pTrans, silMethod)
        )(position)
      case chalice.Assign(v@chalice.VariableExpr(name), rhs) =>
        LocalVarAssign(LocalVar(name)(Int /*YANNIS: todo: fix*/),
          translateExp(rhs.asInstanceOf[chalice.Expression], myThis, pTrans))(position)
          // YANNIS: todo: RHS may be a 'new' expression!
      case chalice.FieldUpdate(ma, rhs) =>
        val silma = translateExp(ma, myThis, pTrans)
        if (!silma.isInstanceOf[FieldAccess]) { messages += TypeError(); null }
        else FieldAssign(silma.asInstanceOf[FieldAccess],
          translateExp(rhs.asInstanceOf[chalice.Expression], myThis, pTrans))()
      // YANNIS: todo: RHS may be a 'new' expression!
      case chalice.LocalVar(v, rhs) if rhs.isInstanceOf[Option[chalice.Expression]] =>
        val silType = translateType(v.t)
        silMethod.locals = silMethod.locals :+ LocalVarDecl(v.id, silType)(position)
          // todo: check how blocks introduce local variables in SIL
        rhs match {
          case None => Seqn(Seq())()
          case Some(e) =>
            LocalVarAssign(LocalVar(v.id)(silType), translateExp(e.asInstanceOf[chalice.Expression], myThis, pTrans))(
              position
            )
        }

      case chalice.LocalVar(v, newO) => null // todo

      case chalice.Call(_, lhs, target, methodName, args) =>
        // YANNIS: todo: implicit locals declaration
          // the first argument of Call is a mask that defines which variables of the lhs are implicitly defined
          // the feature is not yet implemented

        // spot Chalice method object
        val m = target.typ.LookupMember(methodName)

        // spot SIL method object
        val silMethod = m match {
          case None => messages += TypeError() ; return null
          case Some(cMethod) =>
            val s = symbolMap.getOrElse(cMethod, { messages += TypeError() ; return null })
            if(!s.isInstanceOf[Method]) { messages += TypeError() ; return null }
            s.asInstanceOf[Method]
        }

        // create fresh read permission
        val newK = LocalVarDecl(nameGenerator.createIdentifier("newK"), Perm)()

        // create a method call inside a fresh permission block
        FreshReadPerm(Seq(newK.localVar),
          MethodCall(silMethod,
               translateExp(target, myThis, pTrans) /*this*/
            :: newK.localVar /*permission*/
            :: args.map(translateExp(_, myThis, pTrans))/*arguments*/,
            lhs.map(x => LocalVar(x.id)(Int /*YANNIS: todo: fix type*/))/*targets*/
          )(position)
        )(position)

      case chalice.SpecStmt(_, _, _, _) => messages += TypeError() ; null // YANNIS: todo: SpecStatements not supported
      case chalice.Install(_, _, _) => messages += TypeError() ; null // YANNIS: todo: mu reordering not supported yet

      case chalice.Share(obj, _, _) => // YANNIS: todo: mu ordering and deadlock avoidance not supported yet
        // YANNIS: todo: assert that the object is not already shared

        // exhale the monitor invariant
        val monitorPredicate = silTranslatedInvariants.getOrElse(obj.typ, { messages += TypeError() ; return null })
        Exhale(PredicateAccess(translateExp(obj, myThis, pTrans), monitorPredicate)(position))(position)

      case chalice.Unshare(_) => messages += TypeError() ; Seqn(Seq())(position) // YANNIS: todo: unsharing not supported

      case chalice.Acquire(obj) => // YANNIS: todo: mu ordering and deadlock avoidance not supported yet
        // YANNIS: todo: assert that the object is shared, not already held, and the waitlevel is lower than its mu

        // inhale the monitor invariant
        val monitorPredicate = silTranslatedInvariants.getOrElse(obj.typ, { messages += TypeError() ; return null })
        Inhale(PredicateAccess(translateExp(obj, myThis, pTrans), monitorPredicate)(position))(position)

      case chalice.Release(obj) => // YANNIS: todo: mu ordering and deadlock avoidance not supported yet
        // YANNIS: todo: assert that the object is shared and held

        // exhale the monitor invariant
        val monitorPredicate = silTranslatedInvariants.getOrElse(obj.typ, { messages += TypeError() ; return null })
        Exhale(PredicateAccess(translateExp(obj, myThis, pTrans), monitorPredicate)(position))(position)

      // YANNIS: todo several unsupported features
      case chalice.RdAcquire(_) => messages += TypeError() ; null
      case chalice.RdRelease(_) => messages += TypeError() ; null
      case chalice.Lock(_, _, true) // this flag indicates "read" locks
        => messages += TypeError() ; null
      case chalice.Downgrade(_) => messages += TypeError() ; null
      case chalice.Free(_) => messages += TypeError() ; null

      case chalice.Lock(obj, block, false) =>
        val chalEquivalent = chalice.BlockStmt((chalice.Acquire(obj) :: block.ss) :+ chalice.Release(obj))
        translateStm(chalEquivalent, myThis, pTrans, silMethod)

      //forking
      case chalice.CallAsync(_, lhs, obj, id, args) =>
        // YANNIS: todo: implicit locals declaration

        // check if token has appeared in another fork (which is not supported)
        if (joinTokens.contains((silMethod, lhs.id))) { messages += TypeError() ; return null }

        // all generated statements are going here
        val statements = new mutable.MutableList[Stmt]()

        // assert that the token is not joinable
        // todo

        // spot chalice method and store it in joinTokens
        val m = obj.typ.LookupMember(id)
        val cMethod = m match {
          case None => messages += TypeError() ; return null
          case Some(cM) => cM
        }
        val joinableInfo = new JoinableInfo(cMethod.asInstanceOf[chalice.Method])
        joinTokens((silMethod, lhs.id)) = joinableInfo

        // ensure args.length is equal to the number of arguments expected by cMethod
        // todo

        // evaluate arguments and "old" expressions of the postcondition of cMethod and store them in local variables
        // also store the local variable names into joinableInfo.oldExpressions: first all arguments and then all "old"
        // expressions in order of appearance
        val argsAndOldIds = new mutable.MutableList[String]()
        for(i <- 0 until args.length) {
          val name = nameGenerator.createIdentifier("a" + i)
          argsAndOldIds += name
          val silLocalVariable = LocalVarDecl(name, translateType(args(i).typ))(position)
          silMethod.locals = silMethod.locals :+ silLocalVariable
          statements += LocalVarAssign(silLocalVariable.localVar, translateExp(args(0), myThis, pTrans))(position)
        }
        val oldExpressions = Util.getOldExpressions(silMethod.posts)
        for(i <- 0 until oldExpressions.length) {
          val name = nameGenerator.createIdentifier("o" + i)
          argsAndOldIds += name
          val silLocalVariable = LocalVarDecl(name, oldExpressions(i).typ)(position)
          silMethod.locals = silMethod.locals :+ silLocalVariable
          statements += LocalVarAssign(silLocalVariable.localVar, oldExpressions(i))(position)
        }
        joinableInfo.argsAndOldIds = argsAndOldIds.toSeq

        // generate fresh permission variable
        // todo

        // spot SIL method; take its precondition and make argument substitutions (this and K inclusive)
        // store the result into sPre
        // todo

        // exhale sPre
        // todo

        // make token joinable
        // todo
        null
    }
    // YANNIS: todo: finish
    /*
            case class CallAsync(declaresLocal: Boolean, lhs: VariableExpr, obj: Expression, id: String, args: List[Expression]) extends Statement {
    var local: Variable = null
    var m: Method = null
    override def Declares = if (local != null) List(local) else Nil
    override def Targets = if (lhs != null && lhs.v != null) Set(lhs.v) else Set()
    }
      case class JoinAsync(lhs: List[VariableExpr], token: Expression) extends Statement {
    var m: Method = null
    }
      case class Wait(obj: Expression, id: String) extends Statement {
    var c: Condition = null
    }
      case class Signal(obj: Expression, id: String, all: Boolean) extends Statement {
    var c: Condition = null
    }
      case class Send(ch: Expression, args: List[Expression]) extends Statement {
    }
      case class Receive(declaresLocal: List[Boolean], ch: Expression, outs: List[VariableExpr]) extends Statement {
    var locals = List[Variable]()
    override def Declares = locals
    override def Targets = (outs :\ Set[Variable]()) { (ve, vars) => if (ve.v != null) vars + ve.v else vars }
    }
      case class Fold(pred: Access) extends Statement
      case class Unfold(pred: Access) extends Statement

*/
  }

  abstract class PermissionTranslator{
    def getK : Exp  // this is the permission expression that corresponds to rd(o.f)
    // getK is different depending on whether we are in a method, predicate or invariant context
    // in function contexts there is no such value

    def apply(perm: chalice.Permission, myThis: LocalVarDecl) = {
      perm match {
        case chalice.Full => FullPerm()() // 100% permission
        case chalice.Frac(n) => FractionalPerm(translateExp(n, myThis, this), new IntLit(100)())() // n% permission
        case chalice.Star => WildcardPerm()() // rd* permission
        case chalice.Epsilon => getK // represents the permission given by the Chalice expression rd(o.f)
        // attention: chalice.Epsilon is a misnomer!!
        case chalice.MethodEpsilon => getK

        // for predicate and monitor k permissions, we use the global k value
        // the following two cases should only appear in the corresponding contexts
        case chalice.PredicateEpsilon(_) => getK
        case chalice.MonitorEpsilon(_) => getK
        // YANNIS: todo: deal with: case class ForkEpsilon(token: Expression) extends Write

        // counting permissions
        case chalice.Epsilons(n) => IntPermMul(translateExp(n, myThis, this), EpsilonPerm()())() // n*Îµ permissions

        // operations on permissions
        case chalice.PermTimes(lhs, rhs) => PermMul(translateExp(lhs, myThis, this), translateExp(rhs, myThis, this))()
        // multiplication of two fractional permissions
        case chalice.IntPermTimes(n, p) => IntPermMul(translateExp(n, myThis, this), translateExp(p, myThis, this))()
        // multiplication of an integer and a permission
        case chalice.PermPlus(lhs, rhs) =>
          new PermAdd(translateExp(lhs, myThis, this), translateExp(rhs, myThis, this))() // p1+p2
        case chalice.PermMinus(lhs, rhs) =>
          new PermSub(translateExp(lhs, myThis, this), translateExp(rhs, myThis, this))() // p1-p2
      }
    }
  }

  // permission translation in method contexts: getK is a formal parameter of the method
  case class MethodPermissionTranslator(val KVar: LocalVarDecl) extends PermissionTranslator {
    override def getK = KVar.localVar
  }

  // permission translation in predicate and invariant contexts: getK is the global K defined for these contexts
  case class PredicatePermissionTranslator(val globalK: DomainFunc) extends PermissionTranslator {
    override def getK = DomainFuncApp(globalK, Seq(), new scala.collection.immutable.HashMap[TypeVar,Type]())()
  }

  // in functions, all permissions must be translated to starred read permission
  case class FunctionPermissionTranslator() extends PermissionTranslator {
    override val getK = null

    override def apply(perm: chalice.Permission, myThis: LocalVarDecl) = WildcardPerm()()
  }
}

object Util {
  // takes a SIL expression and returns the sequence of all "old" expressions in the order they appear in it
  // (the "old" node is stripped off from the result
  def getOldExpressions(sExp: Seq[Exp]) : Seq[Exp] = {
    val oldExpressions = new mutable.MutableList[Exp]()
    sExp.foreach((e:Exp) => semper.sil.ast.utility.Visitor.visit(e)(
      { case n:Node => { if(n.isInstanceOf[Old]) oldExpressions += n.asInstanceOf[Old].exp ; Unit } }
    ))
    oldExpressions
  }

  // converts a Chalice class to a Chalice type
  def convertToType(cClass: chalice.Class) : chalice.Type = {
    if(cClass == null) return null
    var tParams : List[chalice.Type] = Nil
    if(cClass.parameters != null) tParams = cClass.parameters map convertToType
    new chalice.Type(cClass.classId, tParams)
  }
}

class JoinableInfo(val cMethod: chalice.Method) {
  var argsAndOldIds: Seq[String] = null
}

class SILProgramEnvironment(val silFields: Map[String, Field] = new mutable.HashMap[String, Field],
 val silFunctions: Map[String, Function] = new mutable.HashMap[String, Function],
 val silPredicates: Map[String, Predicate] = new mutable.HashMap[String, Predicate],
 val silMethods: Map[String, Method] = new mutable.HashMap[String, Method]) {
  // field for fork/join tokens
  silFields("joinable") = Field("joinable", Bool)()
}