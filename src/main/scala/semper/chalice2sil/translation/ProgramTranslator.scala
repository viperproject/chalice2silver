/**
 * Author: Yannis Kassios (based on an older version by Christian Klauser)
 */

package semper.chalice2sil.translation

import semper.sil.ast._
import scala.collection._
import mutable.Map
import semper.chalice2sil.messages._
import scala.Some
import chalice.BackPointerMemberAccess

// todo: resolve compiler warnings
// todo: Chalice bug: expression {this} throws matching expression!
// todo: positions do not contain the file name in the reports: fix!

// **
// This is were the magic happens
// **
class ProgramTranslator(val programName: String)
{
  // messages generated in the translation
  val messages = scala.collection.mutable.ListBuffer[ReportMessage]()

  // maps Chalice member names (fields, methods, functions, predicates) to the corresponding SIL entities
    // the string "FullName" of each Chalice member followed by a $ sign is used as key
  val silEnvironment = new SILProgramEnvironment()

  // maps monitor invariants from Chalice to SIL predicates
  val silTranslatedInvariants = new scala.collection.mutable.LinkedHashMap[chalice.Class, Predicate]()

  // maps Chalice members (fields, methods, function, predicates) to corresponding SIL members
  val symbolMap = new scala.collection.mutable.HashMap[chalice.ASTNode, Node]()
    // note: symbolMap does not make the collections in silEnvironment obsolete!  The SIL program has extra symbols
    // silEnvironment does not make symbolMap obsolete either.  symbolMap maps Chalice entities to SIL entities directly
      // the name of the SIL entity cannot be inferred from the name of the Chalice entity

  // contains backpointers found in the Chalice programs
    // (B, A, f) is mapped to the SIL field that corresponds to the backpointer B.~(A.f)
  val backpointerSymbolMap = new scala.collection.mutable.HashMap[(String, String, String), Field]()

  // a sequence of JoinableInfo objects, one per SIL method.  These objects contain information on the specifications
    // of each method, to be used for forking/joing
  val joinableInfo = new collection.mutable.HashMap[Method, JoinableInfo]()

  // name generator -- ensures uniqueness and validity of names of identifiers
    // CONVENTION: all local variables maintain their names from Chalice.  To prevent clashes, all names generated by
    // nameGenerator must include the symbol $
  val nameGenerator = new semper.sil.utility.SilNameGenerator

  // this domain introduces the constant K permission for use in monitor invariants
    // axiom: the K permission is read-only
  val globalK = DomainFunc(nameGenerator.createUniqueIdentifier("globalK$"), Seq(), Perm, true)()
  val globalKApp = DomainFuncApp(globalK, Seq(), new scala.collection.immutable.HashMap[TypeVar,Type]())()
  val axiomKReadOnly = DomainAxiom("globalKReadOnly",
    And(PermGtCmp(globalKApp, NoPerm()())(), PermGtCmp(FullPerm()(), globalKApp)())()
  )()
  val GlobalKPermissionDomain = Domain("GlobalKPermission", Seq(globalK), Seq(axiomKReadOnly))()

  // this variable holds the sil object which is being currently created
    // currently used only for function postconditions
  var workingOn: Node = null

  // **
  // takes a Chalice program as a sequence of Chalice top level declarations
  // produces a SIL program and a sequence of error/warnings
  // **
  def translate(decls : Seq[chalice.TopLevelDecl]) : (Program, Seq[ReportMessage]) = {
    // collect all top level symbols and populates silEnvironment and silInvariants
    decls.foreach(collectSymbols)

    // translate each class
    decls.foreach(translate)

    // translate the bodies of all methods
    symbolMap.foreach{
      case (chm@chalice.Method(_,_,_,_,_), silm@Method(_,_,_,_,_,_,_)) => translateBody(chm, silm)
      case _ =>
    }

    // return the final SIL program together with the list of error/warnings produced
    (Program(Seq(GlobalKPermissionDomain), silEnvironment.silFields.values.toSeq,
      silEnvironment.silFunctions.values.toSeq, silEnvironment.silPredicates.values.toSeq,
      silEnvironment.silMethods.values.toSeq)(),
     messages.toSeq)
  }

  // **
  // collects all symbols associated with a class and populates silEnvironment and silInvariants
  // **
  protected def collectSymbols(decl : chalice.TopLevelDecl) {
    decl match {
      case c:chalice.Class if c.IsNormalClass => collectSymbols(c)
      case node =>
    }
  }

  // **
  // collects all symbols associated with a class and populates silEnvironment and silInvariants
  // **
  protected def collectSymbols(classNode : chalice.Class){
    // create a predicate that corresponds to the monitor invariant of this class
    // the body is to be populated later
    val ths = nameGenerator.createUniqueIdentifier("this$")
    val myThis = LocalVarDecl(ths, Ref)()
    val pName = nameGenerator.createUniqueIdentifier(classNode.FullName + "$MonitorInvariant")
    val invariant = Predicate(pName, List(myThis), null)()
    silTranslatedInvariants(classNode) = invariant
    silEnvironment.silPredicates += (pName -> invariant)

    // collect all symbols for the Chalice class
    classNode.members.view foreach {
      // field
      case f:chalice.Field =>
        val newField = Field(nameGenerator.createUniqueIdentifier(f.FullName+"$"), Util.translateType(f.typ))(
          SourcePosition(null, f.pos.line, f.pos.column)
        )
        symbolMap(f) = newField
        silEnvironment.silFields += (newField.name -> newField)
        if (f.isTracked) {
          // this is a tracked reference: create backpointer field
          val newBackPointerField =
            Field(nameGenerator.createUniqueIdentifier("BP$" + f.FullName+"$"), SetType(Ref))(
              SourcePosition(null, f.pos.line, f.pos.column)
            )
          silEnvironment.silFields += (newBackPointerField.name -> newBackPointerField)
          backpointerSymbolMap += ((f.typ.id, classNode.classId, f.id) -> newBackPointerField)
        }

      // predicate
      case p:chalice.Predicate =>
        val ths = nameGenerator.createUniqueIdentifier("this$")
        val newPredicate =
          Predicate(nameGenerator.createUniqueIdentifier(p.FullName+"$"), List(LocalVarDecl(ths, Ref)()), null)(
            SourcePosition(null, p.pos.line, p.pos.column)
          )
          // a predicate has a single reference parameter that refers to the receiver
          // the body is to be filled later
        symbolMap(p) = newPredicate
        silEnvironment.silPredicates += (newPredicate.name -> newPredicate)

      // method
      case m:chalice.Method =>
        val ths = nameGenerator.createUniqueIdentifier("this$")
        val k = nameGenerator.createUniqueIdentifier("k$")
        val n = nameGenerator.createUniqueIdentifier("n$")
          // this local variable is used always as a temporary variable for storing newly created objects
        val myThis = LocalVarDecl(ths, Ref)()
        val myK = LocalVarDecl(k, Perm)()
        val myN = LocalVarDecl(n, Ref)()
        val ins = myThis :: myK :: translateVars(m.ins)
        val newMethod = Method(nameGenerator.createUniqueIdentifier(m.FullName+"$"), ins, translateVars(m.outs),
          null, null, Seq(myN), null)(SourcePosition(null, m.pos.line, m.pos.column))
          // a method in SIL has a reference parameter that refers to the receiver and a permission parameter that
          // refers to all unspecified read permissions in its precondition
          // the body and the specs are to be filled in later
        symbolMap(m) = newMethod
        silEnvironment.silMethods += (newMethod.name -> newMethod)

      // function
      case f:chalice.Function =>
        val ths = nameGenerator.createUniqueIdentifier("this$")
        val myThis = LocalVarDecl(ths, Ref)()
        val ins = myThis :: translateVars(f.ins)
        val newFunction = Function(nameGenerator.createUniqueIdentifier(f.FullName+"$"), ins, Util.translateType(f.out),
          null, null, null)(SourcePosition(null, f.pos.line, f.pos.column))
          // a function has a reference parameter that refers to the receiver
          // the body and the precondition are to be filled later
        symbolMap(f) = newFunction
        silEnvironment.silFunctions += (newFunction.name -> newFunction)

      // monitor invariant: ignore in this phase
      case i:chalice.MonitorInvariant =>
    }
  }

  // **
  // translates all members of a class and populates missing bodies and specifications in the corresponding SIL members
  // **
  protected def translate(decl : chalice.TopLevelDecl) {
    decl match {
      case c:chalice.Class if c.IsNormalClass => translate(c)

      // only classes are supported as top-level declarations in the present version
      case node => messages += new Channels()
    }
  }

  // **
  // translates all members of a class and populates missing bodies and specifications in the corresponding SIL members
  // also deals with the monitor invariant of a class
  // **
  protected def translate(classNode: chalice.Class) = {
    // get the (bodyless) invariant predicate corresponding to this class, and its receiver
    val invariant = silTranslatedInvariants(classNode)
    val ths = invariant.formalArgs(0)

    // an expression to store the monitor invariant
    var monitorInvariantBody : Exp = TrueLit()()

    // translate one member at a time
    classNode.members.foreach({
      case m: chalice.Method  => translateMethodEarly(m) // translate a method but not its body
      case p: chalice.Predicate => translatePredicate(p)
      case f: chalice.Function => translateFunction(f)
      case i: chalice.MonitorInvariant =>
        // translate the found invariant expression and conjoin it to the already translated invariants
          // all invariants refer to the same receiver object and their read permission is given by globalK
        val currentInv = translateExp(i.e, ths, PredicatePermissionTranslator(globalK))
        monitorInvariantBody = And(currentInv, monitorInvariantBody)()
      case _ => // fields: nothing to do here
    })

    // populate the body of the invariant predicate
    invariant.body = monitorInvariantBody
  }

  // **
  // translates a list of Chalice arguments into the corresponding SIL arguments
  // new local variables with the same name are created
  // **
  protected def translateVars(cVars: Seq[chalice.Variable]) = {
    val result = scala.collection.mutable.ListBuffer[LocalVarDecl]()
    cVars.foreach((x: chalice.Variable) =>
      result += LocalVarDecl(x.id, Util.translateType(x.t))(SourcePosition(null, x.pos.line, x.pos.column))
    )
    result.toList
  }

  // **
  // translate a Chalice predicate into a SIL predicate
  // **
  protected def translatePredicate(cPredicate: chalice.Predicate) = {
    // obtain the corresponding SIL predicate
    val sPredicate = symbolMap(cPredicate).asInstanceOf[Predicate]

    // obtain the first argument of the predicate as the receiver object
      // note that Chalice has no support for predicates with arguments
    val sThis = sPredicate.formalArgs(0)

    // populate the predicate body translating the corresponding Chalice body and using the given receiver and the
    // global unidentified read permission for predicates
    sPredicate.body = translateExp(cPredicate.definition, sThis, PredicatePermissionTranslator(globalK))
  }

  // **
  // translate a Chalice function into a SIL function
  // **
  protected def translateFunction(cFunction: chalice.Function) = {
    // obtain the corresponding SIL function
    val sFunction = symbolMap(cFunction).asInstanceOf[Function]
    workingOn = sFunction

    // obtain the receiver, which is the first in the list of formal arguments of the SIL function
    val sThis = sFunction.formalArgs(0)

    // precondition this!=null
    val thisNotNull = NeCmp(sThis.localVar, NullLit()())()

    // translate specifications
      // all permissions in the preconditions are rendered to a read permission
    val silPreconditions = scala.collection.mutable.ListBuffer[Exp](thisNotNull)
    val silPostConditions = scala.collection.mutable.ListBuffer[Exp]()
    cFunction.spec.foreach {
      _ match {
        case chalice.Precondition(e) => silPreconditions +=
          translateExp(e, sThis, FunctionPermissionTranslator())
        case chalice.Postcondition(e) => silPostConditions +=
          translateExp(e, sThis, FunctionPermissionTranslator())
      }
    }
    sFunction.pres = silPreconditions.toSeq
    sFunction.posts = silPostConditions.toSeq

    // translate body into SIL and populate the body of the SIL function appropriately
      // all permissions in the body are rendered to a read permission
    cFunction.definition match {
      case Some(body) => sFunction.exp = translateExp(body, sThis, FunctionPermissionTranslator())
    }
  }

  // **
  // translate a Chalice method into a SIL method
  // **
  protected def translateMethodEarly(cMethod: chalice.Method) = {
    // obtain the corresponding SIL method
    val sMethod = symbolMap(cMethod).asInstanceOf[Method]

    // obtain receiver, unidentified read permission argument and create a method permission translator
    val sThis = sMethod.formalArgs(0)
    val sK = sMethod.formalArgs(1)
    val permTranslator = MethodPermissionTranslator(sK)

    // precondition this!=null && K>0 && K<Full
    val thisNotNull = NeCmp(sThis.localVar, NullLit()())()
    val kRead = PermGtCmp(sK.localVar, NoPerm()())()
    val kNoWrite = PermGtCmp(FullPerm()(), sK.localVar)()

    // translate specifications
    val silPreconditions = new scala.collection.mutable.ListBuffer[Exp]()
    silPreconditions += (thisNotNull, kRead, kNoWrite)
    val silPostConditions = new scala.collection.mutable.ListBuffer[Exp]()
    cMethod.spec.foreach {
      _ match {
        case chalice.Precondition(e) => silPreconditions += translateExp(e, sThis, permTranslator)
        case chalice.Postcondition(e) => silPostConditions += translateExp(e, sThis, permTranslator)
        case chalice.LockChange(_) => messages += OldLockModel()
      }
    }
    sMethod.pres = silPreconditions.toSeq
    sMethod.posts = silPostConditions.toSeq

    // add information to be stored by forks in this method
    joinableInfo += sMethod -> new JoinableInfo(sMethod, silEnvironment.silFields)
  }

  // **
  // translate a Chalice expression to the corresponding SIL expression
  // uses myThis: the SIL local variable that corresponds to the receiver object of Chalice
  // uses pTrans: a PermissionTranslation object that is used to translate permission-valued expressions according to
  //   whether the expression is found in a method, predicate, or function
  // uses accessMemberSubexpression: to distinguish between two cases in the translation of e.p where p is a predicate
  //   name.  If accessMemberSubexpression is false (default case), then we are not reading within an acc expression,
  //   which translates e.p to a SIL boolean (in fact, acc(e.p, write)).  Otherwise e.p is in the context of an acc
  //   expression (e.g., acc(e.p)) and must be translated as a ``member access'' AST node.  This takes care of an
  //   ambiguity that the Chalice parser causes, because it translates expressions e.p and acc(e.p) differently
  // uses silFunction: optionally, if the expression is found within the specifications of a function
  // **
  protected def translateExp(cExp: chalice.Expression, myThis: LocalVarDecl, pTrans: PermissionTranslator,
                             accessMemberSubexpression: Boolean = false) : Exp = {
    // obtain the Chalice source code position
    val position = SourcePosition(null, cExp.pos.line, cExp.pos.column)

    cExp match {
      // old expression
      case chalice.Old(inner) => Old(translateExp(inner, myThis, pTrans))(position)

      // chalice2sil ignores all deadlock prevention specs in the present version
      case chalice.LockBelow(_,_) =>  messages += DeadlockAvoidance(position) ; TrueLit()(position)
      case chalice.Eq(chalice.MaxLockLiteral(),_) => messages += DeadlockAvoidance(position) ; TrueLit()(position)
      case chalice.Eq(_,chalice.MaxLockLiteral()) => messages += DeadlockAvoidance(position) ; TrueLit()(position)

      // predicate 'holds' is ignored, because it is deprecated
      case chalice.Holds(_) | chalice.RdHolds(_) => messages += OldLockModel(position) ; TrueLit()(position)

      // logical operators
      case chalice.And(lhs, rhs) =>
        And(translateExp(lhs, myThis, pTrans), translateExp(rhs, myThis, pTrans))(position)
      case chalice.Or(lhs, rhs) =>
        Or(translateExp(lhs, myThis, pTrans), translateExp(rhs, myThis, pTrans))(position)
      case chalice.Implies(lhs, rhs) =>
        Implies(translateExp(lhs, myThis, pTrans), translateExp(rhs, myThis, pTrans))(position)
      case chalice.Iff(lhs, rhs) =>
        EqCmp(translateExp(lhs, myThis, pTrans), translateExp(rhs, myThis, pTrans))(position)
      case chalice.Eq(lhs, rhs) =>
        val silLhs = translateExp(lhs, myThis, pTrans)
        val silRhs = translateExp(rhs, myThis, pTrans)
        // the following check avoids mu-comparisons
        if(silLhs == null || silRhs == null) { messages += DeadlockAvoidance(position) ; TrueLit()(position) }
        else EqCmp(silLhs, silRhs)(position)
      case chalice.Neq(lhs, rhs) =>
        NeCmp(translateExp(lhs, myThis, pTrans), translateExp(rhs, myThis, pTrans))(position)
      case chalice.Not(op) => Not(translateExp(op, myThis, pTrans))(position)
      case chalice.IfThenElse(cond, thn, els) =>
        CondExp(
          translateExp(cond, myThis, pTrans), translateExp(thn, myThis, pTrans), translateExp(els, myThis, pTrans)
        )(position)
      case chalice.Neq(lhs, rhs) =>
        NeCmp(translateExp(lhs, myThis, pTrans), translateExp(rhs, myThis, pTrans))(position)

      // arithmetic operators and set union, difference, intersection
      case chalice.Plus(lhs, rhs) =>
        val l = translateExp(lhs, myThis, pTrans)
        val r = translateExp(rhs, myThis, pTrans)
        if(lhs.typ == chalice.IntClass) Add(l, r)(position) // integer addition
        else AnySetUnion(l, r)(position) // set union
      case chalice.Minus(lhs, rhs) =>
        val l = translateExp(lhs, myThis, pTrans)
        val r = translateExp(rhs, myThis, pTrans)
        if(lhs.typ == chalice.IntClass) Sub(l, r)(position) // integer subtraction
        else AnySetMinus(l, r)(position) // set difference
      case chalice.Times(lhs, rhs) =>
        val l = translateExp(lhs, myThis, pTrans)
        val r = translateExp(rhs, myThis, pTrans)
        if(lhs.typ == chalice.IntClass) Mul(l, r)(position) // integer multiplication
        else AnySetIntersection(l, r)(position) // set intersection
      case chalice.Div(lhs, rhs) =>
        Div(translateExp(lhs, myThis, pTrans), translateExp(rhs, myThis, pTrans))(position) // integer division
      case chalice.Mod(lhs, rhs) =>
        Mod(translateExp(lhs, myThis, pTrans), translateExp(rhs, myThis, pTrans))(position) // integer modulo

      // arithmetic and set comparison operators
      case chalice.Less(lhs, rhs) =>
        val l = translateExp(lhs, myThis, pTrans)
        val r = translateExp(rhs, myThis, pTrans)
        if(lhs.typ == chalice.IntClass) LtCmp(l, r)(position) // integer <
        else And(AnySetSubset(l, r)(position), NeCmp(l, r)(position))(position) // strict subset
      case chalice.AtMost(lhs, rhs) =>
        val l = translateExp(lhs, myThis, pTrans)
        val r = translateExp(rhs, myThis, pTrans)
        if(lhs.typ == chalice.IntClass) LeCmp(l, r)(position) // integer <=
        else AnySetSubset(l, r)(position) // non-strict subset
      case chalice.AtLeast(lhs, rhs) =>
        val l = translateExp(lhs, myThis, pTrans)
        val r = translateExp(rhs, myThis, pTrans)
        if(lhs.typ == chalice.IntClass) GeCmp(l, r)(position) // integer >=
        else AnySetSubset(r, l)(position) // non-strict superset
      case chalice.Greater(lhs, rhs) =>
        val l = translateExp(lhs, myThis, pTrans)
        val r = translateExp(rhs, myThis, pTrans)
        if(lhs.typ == chalice.IntClass) GtCmp(l, r)(position) // integer >
        else And(AnySetSubset(r, l)(position), NeCmp(l, r)(position))(position) // strict superset

      // sequence operators
      case chalice.EmptySeq(t) => EmptySeq(Util.translateType(t))(position)
      case s @ chalice.ExplicitSeq(elems) =>
        if (elems.length > 0)
          ExplicitSeq(elems.map(translateExp(_, myThis, pTrans)))(position)
        else EmptySeq(Util.translateType(s.typ))(position)
      case chalice.Range(lhs, rhs) =>
        new RangeSeq(translateExp(lhs, myThis, pTrans), translateExp(rhs, myThis, pTrans))(position)
      case chalice.At(lhs, rhs) =>
        SeqIndex(translateExp(lhs, myThis, pTrans), translateExp(rhs, myThis, pTrans))(position)
      case chalice.Drop(lhs, rhs) =>
        SeqDrop(translateExp(lhs, myThis, pTrans), translateExp(rhs, myThis, pTrans))(position)
      case chalice.Take(lhs, rhs) =>
        SeqTake(translateExp(lhs, myThis, pTrans), translateExp(rhs, myThis, pTrans))(position)
      case chalice.Append(lhs, rhs) =>
        SeqAppend(translateExp(lhs, myThis, pTrans), translateExp(rhs, myThis, pTrans))(position)

      // set operators
      case chalice.EmptySet(t) => EmptySet(Util.translateType(t))(position)
      case chalice.ExplicitSet(elems) => ExplicitSet(elems.map(translateExp(_, myThis, pTrans)))(position)
        // todo: what happens with explicitly empty sets?

      // operators common to sets and sequences
      case chalice.Length(e) =>
        val silexp = translateExp(e, myThis, pTrans)
        if(silexp.typ.isInstanceOf[SeqType]) SeqLength(silexp)(position) else AnySetCardinality(silexp)(position)
      case chalice.Contains(lhs, rhs) =>
        val l = translateExp(lhs, myThis, pTrans)
        val r = translateExp(rhs, myThis, pTrans)
        if(r.typ == SeqType(l.typ)) SeqContains(l, r)(position) else AnySetContains(l, r)(position)

      // member access
      case _: chalice.ThisExpr => myThis.localVar
      case ma@chalice.MemberAccess(e, id) =>
        // special field "mu" is ignored
        if(id == "mu") { messages += DeadlockAvoidance(position) ; return null }

        // translate the receiver expression
        val silexp = translateExp(e, myThis, pTrans)

        // special Chalice field "joinable" is always mapped to the SIL field "joinable$"
        if(id == "joinable") { return FieldAccess(silexp, silEnvironment.silFields("joinable$"))(position) }

        // from the field or predicate name that is being accessed, obtain the relevant SIL object
        val sf = symbolMap(e.typ.LookupMember(id).get)

        if(sf.isInstanceOf[Field]) FieldAccess(silexp, sf.asInstanceOf[Field])(position)
        else{
          val predAccess = PredicateAccess(List(silexp), sf.asInstanceOf[Predicate])(position)
          if(accessMemberSubexpression)
            // we are within an acc predicate: must translate as a ``member access'' SIL AST node
            predAccess
          else
            // this is the case where e.p (where p is a predicate name) appears ``naked'' in a specification
            // what is meant is acc(e.p, write).  the conversion happens here
            PredicateAccessPredicate(predAccess, pTrans(chalice.Full, myThis))(position)
        }

      // backpointer member access
      case chalice.BackPointerMemberAccess(target, typeId, fieldId) =>
        // backpointers under construction
        messages += Backpointers(position)

        // translate the receiver expression
        val silexp = translateExp(target, myThis, pTrans)

        // find the corresponding backpointer field
        val bpf = backpointerSymbolMap((target.typ.id, typeId, fieldId))

        FieldAccess(silexp, bpf)(position)

      // access permissions to a field or predicate
      case chalice.Access(ma, perm) =>
        val silma = translateExp(ma, myThis, pTrans, true)
          // note that the content of the acc expression is translated under condition accessMemberSubexpression

        if(silma == null) { messages += DeadlockAvoidance(position) ; return TrueLit()(position) }
          // in this case we are accessing special field "mu"

        val silpe = pTrans(perm, myThis)
        if (ma.isPredicate) PredicateAccessPredicate(silma.asInstanceOf[PredicateAccess], silpe)(position)
        else FieldAccessPredicate(silma.asInstanceOf[FieldAccess], silpe)(position)

      case chalice.BackPointerAccess(ma, perm) =>
        val silma = translateExp(ma, myThis, pTrans)
        val silpe = pTrans(perm, myThis)
        FieldAccessPredicate(silma.asInstanceOf[FieldAccess], silpe)(position)

      // acc(x.*): access permissions to all fields of an object
      case chalice.AccessAll(obj, perm) =>
        // obtain SIL receiver and permission
        val silo = translateExp(obj, myThis, pTrans)
        val silpe = pTrans(perm, myThis)

        // return the complete permission expression
        grantPermissionToAllFields(obj.typ, silo, silpe, position)

      // access to a specific member (or all members) of all objects in a sequence
      case chalice.AccessSeq(seq, member, perm) =>
        // obtain the SIL sequence expression and the permission
        val silseq = translateExp(seq, myThis, pTrans)
        val silpe = pTrans(perm, myThis)

        // the following closure takes a SIL object expression and returns a SIL expression that grants appropriate
        // access to member "member" of the corresponding SIL object
        // if "member" is None, this means access to all fields of the object
        // NOTE: acc(x[*].*) silently succeeds and produces "true" when x[i] is not a reference. This is allowed here,
        // since it is allowed in Chalice (either as a bug or as a feature)
        var permissionPerObject : Exp => Exp = null
        member match {
          case None =>
            // permissionPerObject must return permission to all the fields of silo
            permissionPerObject = (silo:Exp) => {
              // return permission to all the fields of silo
              grantPermissionToAllFields(seq.typ.parameters(0), silo, silpe, position)
            }
          case Some(m) =>
            // permissionPerObject must return permission to member m
            if(m.isPredicate) {
               val silm = symbolMap(m.predicate).asInstanceOf[Predicate]
               permissionPerObject = (silo: Exp) =>
                PredicateAccessPredicate(PredicateAccess(Seq(silo), silm)(position), silpe)(position)
            }
            else {
              val silm = symbolMap(m.f).asInstanceOf[Field]
              permissionPerObject = (silo: Exp) =>
                FieldAccessPredicate(FieldAccess(silo, silm)(position), silpe)(position)
            }
        }

        // return a universal quantification on all sequence elements
        // bounded identifier
        val boundedId = LocalVarDecl(nameGenerator.createUniqueIdentifier("i$"), Int)()

        // restrain identifier to sequence indices
        val boundedIdDomain = And(
          LeCmp(IntLit(0)(), boundedId.localVar)(),
          LtCmp(boundedId.localVar, SeqLength(silseq)())()
        )()

        // grant permissions for any object i in the sequence
        val quantBody = permissionPerObject(SeqIndex(silseq, boundedId.localVar)())

        // return the full quantification
        Forall(List(boundedId), List(), Implies(boundedIdDomain, quantBody)())(position)

      // unfolding
      case unfolding@chalice.Unfolding(predicateAccess, body) =>
        val silpa = translateExp(predicateAccess, myThis, pTrans)
        val silbody = translateExp(body, myThis, pTrans)
        Unfolding(silpa.asInstanceOf[PredicateAccessPredicate], silbody)(position)

      // eval is not supported
      case e: chalice.Eval => messages += Eval(position) ; TrueLit()(position)
        // todo: the above code assumes that the eval expression is always of type bool. check if this is the case

      // function application
      case fa@chalice.FunctionApplication(receiver, funName, args) =>
        val chaliceFunction = receiver.typ.LookupMember(funName).get
        val silFunction = symbolMap(chaliceFunction).asInstanceOf[Function]
        val silReceiver = translateExp(receiver, myThis, pTrans)
        val silArgs = args.map(translateExp(_, myThis, pTrans))
        FuncApp(silFunction, silReceiver :: silArgs)(position)

      // quantification and aggregation
      case e: chalice.Quantification =>
        // keep list of bounded variables and domain expression
        var boundedVars : List[LocalVarDecl] = null
        var domainExpression: Exp = TrueLit()()

        // populate boundedVars and domainExpression according to the flavor of the quantification
        // CONVENTION: like other local Chalice variables, the bounded variables retain their name in SIL!
        if (e.isInstanceOf[chalice.TypeQuantification])
          boundedVars = e.Is map {
            i => LocalVarDecl(i, Util.translateType(e.asInstanceOf[chalice.TypeQuantification].t))()
          }
        else if (e.isInstanceOf[chalice.SeqQuantification]) {
          val seq = e.asInstanceOf[chalice.SeqQuantification].seq
          val silseq = translateExp(seq, myThis, pTrans)
          val tp = Util.translateType(seq.typ.asInstanceOf[chalice.SeqClass].parameter)
          boundedVars = e.Is map { i =>
            domainExpression = And(domainExpression, SeqContains(LocalVar(i)(tp), silseq)())()
            LocalVarDecl(i, tp)()
          }
        }
        else {  // set quantification
          val set =  e.asInstanceOf[chalice.SetQuantification].dom
          val tp = Util.translateType(set.typ.asInstanceOf[chalice.SetClass].parameter)
          val silset = translateExp(set, myThis, pTrans)
          boundedVars = e.Is map { i =>
            domainExpression = And(domainExpression, AnySetContains(LocalVar(i)(tp), silset)())()
            LocalVarDecl(i, tp)()
          }
        }

        // translate the body of the quantification
        val silbody = translateExp(e.E, myThis, pTrans) // e.E refers to the body of the quantification
        e.Q match {
          case chalice.Forall => Forall(boundedVars, Seq(), Implies(domainExpression, silbody)())(position)
          case chalice.Exists =>  Exists(boundedVars, And(domainExpression, silbody)())(position)
          case _ => messages += Aggregates(position) ; null // todo: fix null pointer exceptions here!
        }

      case p:chalice.Permission => pTrans(p, myThis)

      // literals
      case chalice.BoolLiteral(b) => if(b) TrueLit()(position) else FalseLit()(position)
      case chalice.IntLiteral(n) => IntLit(n)(position)
      case chalice.NullLiteral() => NullLit()(position)
      case chalice.StringLiteral(s) => messages += Strings(position) ; null
      case chalice.LockBottomLiteral() => messages += DeadlockAvoidance(position) ; null
      case chalice.MaxLockLiteral() => messages += DeadlockAvoidance(position) ; null
      case chalice.ImplicitThisExpr() => myThis.localVar
      case chalice.ExplicitThisExpr() => myThis.localVar

      // local variable
      case chalice.VariableExpr(v) => LocalVar(v)(Util.translateType(cExp.typ))

      // result
      case chalice.Result() => Result()(workingOn.asInstanceOf[Function].typ)
    }
  }

  // **
  // translate the body of a Chalice method and then assign it to the corresponding SIL method
  // **
  protected def translateBody(cMethod: chalice.Method, sMethod: Method) {
    val sThis = sMethod.formalArgs(0)
    val pTrans = new MethodPermissionTranslator(sMethod.formalArgs(1))

    // translate all statements in the Chalice body and assign the result to the SIL method body
    sMethod.body = Seqn(cMethod.body.map(translateStm(_, sThis, pTrans, sMethod)))()
  }

  // **
  // translate a Chalice statement to the corresponding SIL statement(s)
  // uses myThis: the SIL local variable that corresponds to the receiver object of Chalice
  // uses pTrans: a PermissionTranslation object that is used to translate permission-valued expressions
  // uses silMethod: the SIL method to which the code begins; used mainly for local variable declarations
  // **
  protected def translateStm(cStm: chalice.Statement, myThis: LocalVarDecl,
                             pTrans: PermissionTranslator, silMethod: Method) : Stmt = {
    val position = new SourcePosition(null, cStm.pos.line, cStm.pos.column)
    cStm match {
      // assert and assume
      case chalice.Assert(e) => Assert(translateExp(e, myThis, pTrans))(position)
      case chalice.Assume(e) => Inhale(translateExp(e, myThis, pTrans))(position)

      // basic structuring
      case chalice.BlockStmt(ss) => Seqn(ss.map(translateStm(_, myThis, pTrans, silMethod)))(position)
      case chalice.IfStmt(guard, chalice.BlockStmt(thn), els) =>
        If(translateExp(guard, myThis, pTrans), Seqn(thn.map(translateStm(_, myThis, pTrans, silMethod)))(),
          els match {
            case None => Seqn(Seq())()
            case Some(s) => translateStm(s, myThis, pTrans, silMethod)
          }
        )(position)
      case w@chalice.WhileStmt(guard, _, _, lockchange, body) =>
        // lockchange is not supported anymore
        if(lockchange!=null && !lockchange.isEmpty) messages += OldLockModel(position)

        // todo: what is the difference between newInvs and oldInvs?
        While(translateExp(guard, myThis, pTrans), w.Invs.map(translateExp(_, myThis, pTrans)), Seq(),
          translateStm(body, myThis, pTrans, silMethod)
        )(position)

      // local variable assignment
      case chalice.Assign(v@chalice.VariableExpr(name), rhs) if rhs.isInstanceOf[chalice.Expression] =>
        LocalVarAssign(LocalVar(name)(Util.translateType(rhs.typ)),
          translateExp(rhs.asInstanceOf[chalice.Expression], myThis, pTrans))(position)

      // field update
      case chalice.FieldUpdate(ma, rhs) if rhs.isInstanceOf[chalice.Expression] =>
        val silma = translateExp(ma, myThis, pTrans)
        FieldAssign(silma.asInstanceOf[FieldAccess],
          translateExp(rhs.asInstanceOf[chalice.Expression], myThis, pTrans))(position)
          // todo: add code for backpointers

      // local variable declaration with possible initialization
      case chalice.LocalVar(v, rhs) if (rhs match {
          // the purpose of this ugly check is to ensure that the rhs is not a Chalice "new" expression
          // this patch is a workaround through JVM type erasure
          case None => true
          case Some(e) => try { e.asInstanceOf[chalice.Expression]; true } catch { case _ => false }
        })
          =>
        val silType = Util.translateType(v.t)
        val localVar = LocalVarDecl(v.id, silType)(position)

        // declare the variable only if it is not declared
        if(!silMethod.locals.contains(localVar)) silMethod.locals = silMethod.locals :+ localVar

        rhs match {
          case None => Seqn(Seq())()
          case Some(e) =>
            LocalVarAssign(
              localVar.localVar, translateExp(e.asInstanceOf[chalice.Expression], myThis, pTrans)
            )(position)
        }

      // creation of new objects
      case chalice.Assign(v@chalice.VariableExpr(name), _) =>
        val newVariable = silMethod.locals(0)
        Seqn(Seq(
          Util.newObject(newVariable.localVar, position),
          LocalVarAssign(LocalVar(name)(Ref), newVariable.localVar)(position)
        ))(position)
      case chalice.FieldUpdate(ma, _) =>
        val newVariable = silMethod.locals(0)
        val silma = translateExp(ma, myThis, pTrans)
        Seqn(Seq(
          Util.newObject(newVariable.localVar, position),
          FieldAssign(silma.asInstanceOf[FieldAccess], newVariable.localVar)(position)
        ))(position)
      case chalice.LocalVar(v, _) =>
        val localVar = LocalVarDecl(v.id, Ref)(position)
        // declare the variable only if it is not declared
        if(!silMethod.locals.contains(localVar)) silMethod.locals = silMethod.locals :+ localVar
        Util.newObject(localVar.localVar, position)

      // call
      case chalice.Call(_, lhs, target, methodName, args) =>
        // todo: implicit locals declaration (same issue in forks/joins)
          // the first argument of Call is a mask that defines which variables of the lhs are implicitly defined
          // the feature is not yet implemented

        // spot Chalice and SIL method object
        val chaliceMethod = target.typ.LookupMember(methodName).get
        val silMethod = symbolMap(chaliceMethod).asInstanceOf[Method]

        // create fresh read permission
        val newK = LocalVarDecl(nameGenerator.createUniqueIdentifier("newK$"), Perm)()

        // create a method call inside a fresh permission block
        FreshReadPerm(Seq(newK.localVar),
          MethodCall(silMethod,
               translateExp(target, myThis, pTrans) /*this*/
            :: newK.localVar /*permission*/
            :: args.map(translateExp(_, myThis, pTrans)) /*arguments*/,
            lhs.map(x => LocalVar(x.id)(Util.translateType(x.typ)))/*targets*/
          )(position)
        )(position)

      // locks
        // mu ordering and deadlock avoidance not supported yet
        // there is no way to assert if an object is shared/held or not: implement new obligations model

      // mu reordering; not supported
      case chalice.Install(_, _, _) => messages += MuReordering(position) ; Seqn(Seq())(position)

      // sharing
      case chalice.Share(obj, _, _) =>
        messages += DeadlockAvoidance(position)
        messages += OldLockModel(position)

        // exhale the monitor invariant
        val monitorPredicate = silTranslatedInvariants(obj.typ)
        val target = List(translateExp(obj, myThis, pTrans))
        Seqn(Seq(
         Fold(
           PredicateAccessPredicate(
             PredicateAccess(target, monitorPredicate)(position), FullPerm()())(position))(position),
         Exhale(
             PredicateAccessPredicate(PredicateAccess(target, monitorPredicate)(position), FullPerm()())(position)
         )(position)
        ))(position)

      // acquiring
      case chalice.Acquire(obj) =>
        messages += DeadlockAvoidance(position)
        messages += OldLockModel(position)

        // inhale the monitor invariant
        val monitorPredicate = silTranslatedInvariants(obj.typ)
        val target = List(translateExp(obj, myThis, pTrans))
        Seqn(Seq(
          Inhale(
            PredicateAccessPredicate(PredicateAccess(target, monitorPredicate)(position), FullPerm()())(position)
          )(position),
          Unfold(
            PredicateAccessPredicate(
              PredicateAccess(target, monitorPredicate)(position), FullPerm()())(position))(position)
        ))(position)

      // release
      case chalice.Release(obj) =>
        messages += DeadlockAvoidance(position)
        messages += OldLockModel(position)

        // exhale the monitor invariant
        val monitorPredicate = silTranslatedInvariants(obj.typ)
        val target = List(translateExp(obj, myThis, pTrans))
        Seqn(Seq(
          Fold(
            PredicateAccessPredicate(
              PredicateAccess(target, monitorPredicate)(position), FullPerm()())(position))(position),
          Exhale(
            PredicateAccessPredicate(PredicateAccess(target, monitorPredicate)(position), FullPerm()())(position)
          )(position)
        ))(position)

      // the lock statement [[...]]
      case chalice.Lock(obj, block, false) => // this flag indicates normal "write" locks
        // craft a Chalice equivalent and translate it
        val chalEquivalent = chalice.BlockStmt((chalice.Acquire(obj) :: block.ss) :+ chalice.Release(obj))
        translateStm(chalEquivalent, myThis, pTrans, silMethod)

      // folding and unfolding
      case e @ chalice.Fold(access) =>
        Fold(
          PredicateAccessPredicate(
            translateExp(access.ma, myThis, pTrans, true).asInstanceOf[PredicateAccess],
            pTrans(access.perm, myThis)
          )(position)
        )(position)
      case chalice.Unfold(access) =>
        Unfold(
          PredicateAccessPredicate(
            translateExp(access.ma, myThis, pTrans, true).asInstanceOf[PredicateAccess],
            pTrans(access.perm, myThis)
          )(position)
        )(position)

      // several unsupported features
      case chalice.RdAcquire(_) => messages += ReadLocks(position) ; Seqn(Seq())(position)
      case chalice.RdRelease(_) => messages += ReadLocks(position) ; Seqn(Seq())(position)
      case chalice.SpecStmt(_, _, _, _) => messages += SpecStatement(position) ; Seqn(Seq())(position)
      case chalice.Lock(_, _, true) // this flag indicates "read" locks
        => messages += ReadLocks(position) ; Seqn(Seq())(position)
      case chalice.Downgrade(_) => messages += UnsupportedStatement("downgrade", position) ; Seqn(Seq())(position)
      case chalice.Free(_) => messages += UnsupportedStatement("free", position) ; Seqn(Seq())(position)
      case chalice.Unshare(_) => messages += UnsupportedStatement("unshare", position) ; Seqn(Seq())(position)
      case chalice.Wait(_, _) => messages += Signals(position) ; Seqn(Seq())(position)
      case chalice.Signal(_, _, _) => messages += Signals(position) ; Seqn(Seq())(position)
      case chalice.Send(_, _) => messages += Channels(position) ; Seqn(Seq())(position)
      case chalice.Receive(_, _, _) => messages += Channels(position) ; Seqn(Seq())(position)

/*  the relevant chalice code for the convenience of the implementer:
case class Wait(obj: Expression, id: String) extends Statement {
var c: Condition = null
}
case class Signal(obj: Expression, id: String, all: Boolean) extends Statement {
var c: Condition = null
}
case class Send(ch: Expression, args: List[Expression]) extends Statement {
}
case class Receive(declaresLocal: List[Boolean], ch: Expression, outs: List[VariableExpr]) extends Statement {
var locals = List[Variable]()
override def Declares = locals
override def Targets = (outs :\ Set[Variable]()) { (ve, vars) => if (ve.v != null) vars + ve.v else vars }
}

*/

      //forking
      case chalice.CallAsync(_, lhs, target, id, args) =>
        // spot Chalice and SIL method object
        val forkedChaliceMethod = target.typ.LookupMember(id).get.asInstanceOf[chalice.Method]
        val forkedSilMethod = symbolMap(forkedChaliceMethod).asInstanceOf[Method]

        // create fresh read permission
        val newK = LocalVarDecl(nameGenerator.createUniqueIdentifier("newK$"), Perm)()

        // calculate target
        val targetObject = translateExp(target, myThis, pTrans)

        // substitute parameters in preconditions
        var actualParameters = collection.mutable.Map(
          myThis.name -> targetObject, pTrans.asInstanceOf[MethodPermissionTranslator].KVar.name -> newK.localVar
        )
        var i = 0
        args foreach ({
          a =>
            actualParameters +=
              (forkedChaliceMethod.ins(i).id -> translateExp(a, myThis, MethodPermissionTranslator(newK)))
            i+=1
        })
        val preconditionsWithActualParameters = forkedSilMethod.pres.map({
         prec => prec.transform()(post = { case n@LocalVar(id) => actualParameters.getOrElse(id, n) })
        })
        val preconditionToExhale = preconditionsWithActualParameters.asInstanceOf[Seq[Exp]].
          fold(TrueLit()(position))((x, y) => And(x, y)(position))

        // find corresponding joinable object
        val thisJoinableInfo = joinableInfo(forkedSilMethod)

        val joinTokenAssignments =
          if(lhs != null) {
            // find or create local variable that corresponds to the join token
            val tokenVar =
              silMethod.locals.find((lvd) => lvd.name == lhs.id).getOrElse {
              val newTokenVar = LocalVarDecl(lhs.id, Ref)(position)
              silMethod.locals = silMethod.locals ++ Seq(newTokenVar)
              newTokenVar
            }

            // assign to token the fresh local permission
            val assignPermission =
              FieldAssign(
                FieldAccess(tokenVar.localVar, Field("old$methodPermission", Perm)())(position), newK.localVar
              )(position)

            // make token joinable
            val makeJoinable =
              FieldAssign(
                FieldAccess(tokenVar.localVar, Field("joinable$", Bool)())(position), TrueLit()(position)
              )(position)

            // calculate all old expressions and assign them to the fields of the token
            val oldAssignments = for(i <- 0 until thisJoinableInfo.oldExpressions.length)
            yield FieldAssign(
                FieldAccess(tokenVar.localVar, thisJoinableInfo.oldFields(i))(position),
                thisJoinableInfo.oldExpressions(i).
                  transform()(post = { case n@LocalVar(id) => actualParameters.getOrElse(id, n) })
              )(position)

            // assign to parameter fields the current values of the input parameters
            val parAssignments = for(i <- 0 until thisJoinableInfo.parameterFields.length) yield
              FieldAssign(
                FieldAccess(tokenVar.localVar, thisJoinableInfo.parameterFields(i))(position),
                actualParameters(forkedSilMethod.formalArgs(i).name)
              )(position)

            // put all join-token-related assignments together
            Seq(makeJoinable, assignPermission) ++ oldAssignments ++ parAssignments
          }
          else Seq()

        // exhale the precondition
        val exhalePrecondition = Exhale(preconditionToExhale)(position)

        // put everything inside a fresh permission block
        FreshReadPerm(Seq(newK.localVar), Seqn(joinTokenAssignments ++ Seq(exhalePrecondition))(position))(position)

      // joining
      case chalice.JoinAsync(lhs, token) =>
        // joining requires deadlock avoidance
        messages += DeadlockAvoidance(position)

        // translate the token expression
        val silToken = translateExp(token, myThis, pTrans)

        // obtain the method to be joined
        val chaliceMethod = token.typ.asInstanceOf[chalice.TokenClass].method
        val silMethod = symbolMap(chaliceMethod).asInstanceOf[Method]

        Seqn(
          Seq(
            // assert the thread is joinable
            Assert(FieldAccess(silToken, Field("joinable$", Bool)(position))(position))(position),

            // join method with key i
            {
                 // calculate actual condition to inhale
                   // take method postconditions and substitute in-parameters with corresponding par-fields accesses,
                   // old expressions with corresponding old-fields accesses, and out-parameters with variables from
                   // the lhs of the join
                 var oldExpIndex = -1
                 val postconditionsWithActualParameters = silMethod.posts.map({
                   post => post.transform()(post = {
                       case n@LocalVar(id) =>
                         if(silMethod.formalArgs.map(_.name).contains(id)) {
                           // this is an in-parameter, to be substituted with the corresponding par-field
                           FieldAccess(silToken, joinableInfo(silMethod).yieldParFieldByName(id).get)()
                         }
                         else if(silMethod.formalReturns.map(_.name).contains(id)) {
                           // this is an out-parameter, to be substituted with the corresponding local variable that
                             // appears in the join statement
                           val indexOfReturnArgument =
                             silMethod.formalReturns.map(_.name).indexWhere(n => n==id)
                           LocalVar(lhs(indexOfReturnArgument).id)(Util.translateType(lhs(indexOfReturnArgument).typ))
                         }
                         else n // no substitution
                       case Old(_) =>
                         // "old" expression found, to be substituted with corresponding field access
                         oldExpIndex += 1
                         FieldAccess(silToken, joinableInfo(silMethod).oldFields(oldExpIndex))()
                     }
                   )
                 })

                 // inhale all postconditions
                 Inhale(
                   postconditionsWithActualParameters.fold(TrueLit()(position))((x, y) => And(x, y)(position))
                 )(position)
               },

              // assign joinable to false
              FieldAssign(
                FieldAccess(silToken, Field("joinable$", Bool)(position))(position), FalseLit()(position))(position)
            )
         )(position)
    }
  }

  // **
  // creates a SIL expression that grants permission to all fields of an object
  // Note: no special fields (such as joinable and mu) and no backpointers are included
  // **
  protected def grantPermissionToAllFields(cls: chalice.Class, silo: Exp, silpe: Exp, position: Position) : Exp = {
    var silexp : Exp = TrueLit()(position)
    cls.members.foreach{ f =>
      val sf = symbolMap.getOrElse(f, null)
      if (sf != null) {
        val newConjunct =
          if(sf.isInstanceOf[Field])
            FieldAccessPredicate(FieldAccess(silo, sf.asInstanceOf[Field])(position), silpe)(position)
          else if(sf.isInstanceOf[Predicate])
            PredicateAccessPredicate(PredicateAccess(List(silo), sf.asInstanceOf[Predicate])(position), silpe)(position)
          else null
        if(newConjunct != null) silexp = And(silexp, newConjunct)(position)
      }
    }
    silexp
  }


  // **
  // superclass of all permission translators
  // a permission translator takes a Chalice permission expression and translates it to the appropriate SIL permission
  // expresssion
  // **
  abstract class PermissionTranslator {
    def getK : Exp
      // this is the permission expression that corresponds to rd(o.f)
      // getK is different depending on whether we are in a method, predicate or invariant context
      // in function contexts there is no such value

    // **
    // default translation
    // **
    def apply(perm: chalice.Permission, myThis: LocalVarDecl) = {
      perm match {
        case chalice.Full => FullPerm()() // 100% permission
        case chalice.Frac(n) => FractionalPerm(translateExp(n, myThis, this), new IntLit(100)())() // n% permission
        case chalice.Star => WildcardPerm()() // rd* permission
        case chalice.Epsilon => getK // represents the permission given by the Chalice expression rd(o.f)
          // attention: chalice.Epsilon is a misnomer!!
        case chalice.MethodEpsilon => getK

        // for predicate and monitor k permissions, we use the global k value
        // the following two cases should only appear in the corresponding contexts
        case chalice.PredicateEpsilon(_) => getK
        case chalice.MonitorEpsilon(_) => getK
        // todo: deal with: case class ForkEpsilon(token: Expression) extends Write

        // counting permissions
        case chalice.Epsilons(n) => IntPermMul(translateExp(n, myThis, this), EpsilonPerm()())() // n*ε permissions

        // operations on permissions
        case chalice.PermTimes(lhs, rhs) => PermMul(translateExp(lhs, myThis, this), translateExp(rhs, myThis, this))()
          // multiplication of two fractional permissions
        case chalice.IntPermTimes(n, p) => IntPermMul(translateExp(n, myThis, this), translateExp(p, myThis, this))()
          // multiplication of an integer and a permission
        case chalice.PermPlus(lhs, rhs) =>
          new PermAdd(translateExp(lhs, myThis, this), translateExp(rhs, myThis, this))() // p1+p2
        case chalice.PermMinus(lhs, rhs) =>
          new PermSub(translateExp(lhs, myThis, this), translateExp(rhs, myThis, this))() // p1-p2
      }
    }
  }

  // permission translation in method contexts: getK is a formal parameter of the method
  case class MethodPermissionTranslator(val KVar: LocalVarDecl) extends PermissionTranslator {
    override def getK = KVar.localVar
  }

  // permission translation in predicate and invariant contexts: getK is the global K defined for these contexts
  case class PredicatePermissionTranslator(val globalK: DomainFunc) extends PermissionTranslator {
    override def getK = DomainFuncApp(globalK, Seq(), new scala.collection.immutable.HashMap[TypeVar,Type]())()
  }

  // in functions, all permissions must be translated to starred read permission
  case class FunctionPermissionTranslator() extends PermissionTranslator {
    override val getK = null

    override def apply(perm: chalice.Permission, myThis: LocalVarDecl) = WildcardPerm()()
  }
}

// **
// utility functions
// **
object Util {
  // **
  // takes a SIL expression and returns the sequence of all "old" expressions in the order they appear in it
  // (the "old" node is stripped off from the result
  // **
  def getOldExpressions(sExp: Seq[Exp]) : Seq[Exp] = {
    val oldExpressions = new mutable.MutableList[Exp]()
    sExp.foreach((e:Exp) => semper.sil.ast.utility.Visitor.visit(e, semper.sil.ast.utility.Nodes.subnodes)(
      { case n:Node => { if(n.isInstanceOf[Old]) oldExpressions += n.asInstanceOf[Old].exp ; Unit } }
    ))
    oldExpressions
  }

  // **
  // converts a Chalice class to a Chalice type
  // **
  def convertToType(cClass: chalice.Class) : chalice.Type = {
    if(cClass == null) return null
    var tParams : List[chalice.Type] = Nil
    if(cClass.parameters != null) tParams = cClass.parameters map convertToType
    new chalice.Type(cClass.classId, tParams)
  }

  // **
  // generates a SIL 'new' statement
  // **
  def newObject(n: LocalVar, p: Position) = NewStmt(n)(p)
    // todo: semantics of new in SIL and Silicon
    // what access permissions do we have on the fields of the new object?
    // is there any policy regarding initial values?
    // is the new statement SIL AST changing any time soon?
    // also: concerns the implementation of backpointers

  // **
  // translates a Chalice class into a SIL type
  // **
  def translateType(cType: chalice.Class) : Type = translateType(convertToType(cType))

  // **
  // translates a Chalice type into a SIL type
  // **
  def translateType(cType: chalice.Type) : Type = {
    cType.id match {
      case "seq" => SeqType(translateType(cType.params(0)))
      case "set" => SetType(translateType(cType.params(0)))
      case "int" => Int
      case "bool" => Bool
      case "$Permission" => Perm
      case _ => Ref
      // todo: add other Chalice-internal classes
    }
  }
}

// **
// stores information about a token
// **
class JoinableInfo(val method: Method, val silFields: mutable.Map[String, Field]) {
  // stores expressions found within "old" in the postconditions of the method
  val oldExpressions = Util.getOldExpressions(method.posts)

  // for each "old" expression, generates a field of the appropriate type
    // the policy for names of such fields guarantees no clashes with other names generated by Chalice2SIL
  val oldFields = for(i <- 0 until oldExpressions.length) yield {
    val res = Field("old$" + method.name + i, oldExpressions(i).typ)()
    silFields += (res.name -> res)
    res
  }

  // for each input parameter, generates a field of the appropriate type
  val parameterFields = for(i <- 0 until method.formalArgs.length)  yield {
    val res = Field("par$" + method.name + method.formalArgs(i).name, method.formalArgs(i).typ)()
    silFields += (res.name -> res)
    res
  }

  // searches parameter fields by name of field
  def yieldParFieldByName(name: String) = parameterFields.find(f => f.name == "par$" + method.name + name)
}


// **
// lexical environment of the SIL program
// **
class SILProgramEnvironment(
 val silFields: Map[String, Field] = new mutable.LinkedHashMap[String, Field],
 val silFunctions: Map[String, Function] = new mutable.LinkedHashMap[String, Function],
 val silPredicates: Map[String, Predicate] = new mutable.LinkedHashMap[String, Predicate],
 val silMethods: Map[String, Method] = new mutable.LinkedHashMap[String, Method]) {
  // each fork stores the abstract permission associated with it in this field of the token it returns
  silFields += ("old$methodPermission" -> Field("old$methodPermission", Perm)())

  // field joinable$ records whether a token can be joined
  silFields += ("joinable$" -> Field("joinable$", Bool)())
}